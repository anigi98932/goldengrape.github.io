<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GoldenGrape's Blog</title><link>https://goldengrape.github.io/</link><description>This is a blog site for GoldenGrape.</description><atom:link href="https://goldengrape.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>zh_cn</language><copyright>Contents © 2018 &lt;a href="mailto:https://twitter.com/goldengrape"&gt;Golden Grape&lt;/a&gt; </copyright><lastBuildDate>Thu, 31 May 2018 18:00:28 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>人工晶体轶事(1)</title><link>https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;人工晶体, 或者人工晶状体, Intraocular lens, 缩写是IOL, 是用来替换天然晶状体的一片微型的透镜, 通常用在白内障手术中.
&lt;!-- TEASER_END --&gt;&lt;/p&gt;
&lt;h2&gt;人工晶体轶事之一, 人工晶体发明的故事&lt;/h2&gt;
&lt;h3&gt;Gordon Cleaver&lt;sup id="fnref-1"&gt;&lt;a class="footnote-ref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fn-1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;1940年8月15日, 伦敦西南的温切斯特, 空袭警报响起.&lt;/p&gt;
&lt;p&gt;德军的轰炸机来得太快了, 直扑机场而来, 想在遇到拦截之前直接摧毁整个空军基地. 皇家空军601中队空军上尉(Flying Officer) Gordon Cleaver冒着硝烟, 奔向跑道上自己的飓风歼击机, 匆忙中他没有戴上护目镜, 就在敌机的轰炸中紧急起飞.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://d.ibtimes.co.uk/en/full/313242/hurricane.jpg"&gt;
(https://www.ibtimes.co.uk)&lt;/p&gt;
&lt;p&gt;Cleaver上尉参加过敦克尔克的战役, 他操纵飓风歼击机无比灵巧, 因此获得了"老鼠"的绰号, 在一年多的战斗飞行中击落了7-9架敌机. 升空后他很快抓到机会击落了一家德军飞机. 突然, Cleaver双眼一黑知道自己被击中了, 他已经无法控制飞机, 只好弃机跳伞, 降落在南安普敦.&lt;/p&gt;
&lt;p&gt;在医院, Cleaver得知当时子弹击中了座舱盖, 将座舱盖打得粉碎, 碎片打中了自己的脸. 右眼已经完全看不见光感, 眼科医生Harold Ridley说对右眼已经无能为力了, 左眼也被弹片击中, 虽然角膜被打穿, 但弹片并没有打碎晶状体, 而是停留在了眼睛里, 而且座舱盖弹片是透明的, 视力虽然下降, 但多少还是能看清些东西. Ridley医生人很好, 经常过来看这只受伤的左眼, 他说只要不感染, 还是有希望恢复一些视力的.&lt;/p&gt;
&lt;p&gt;也许当时戴上护目镜, 世界就会不一样吧.&lt;/p&gt;
&lt;h3&gt;Harold Ridley&lt;sup id="fnref-2"&gt;&lt;a class="footnote-ref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fn-2"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;Gordon Cleaver上尉是个坚强的军人, 头面部的创伤经过了18次的手术才算治疗完成. 他也是个有趣的病例, 飓风战斗机的座舱盖弹片居然安静地留在他的左眼里, 没有引起感染和排异反应. 最让人担心的眼内炎并没有发生.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Harold Ridley" src="https://i.loli.net/2018/06/01/5b103665eb0aa.png"&gt;
(https://www.rayner.com/media/pdf/Invention_of_the_IOL.pdf)&lt;/p&gt;
&lt;p&gt;Ridley医生很想知道座舱盖的材料, 战时打听战斗机的材料多多少少有些麻烦, 但后来总算查到了, 是帝国化工(ICI)生产的Perspex. 这种材料在1928年已经被制造出来, 叫做聚甲基丙烯酸甲酯, 缩写是PMMA, 也被称为有机玻璃. 1930年ICI注册了Perspex的商标. 这种材料透光性很好, 比玻璃轻很多, 有一点点弹性, 不像玻璃那么容易破碎, 即使破碎了, 碎片也一般不会那么锋利. 但显然Perspex还是无法抵抗机枪子弹的威力.&lt;/p&gt;
&lt;p&gt;通常情况下弹片打进身体会引起严重的免疫排异反应, 毕竟这是一种异物. 但Cleaver上尉眼睛里的PMMA弹片却是个例外, 原因可能有两个, 一是PMMA是一种聚合物, 不容易释放出什么离子或者小分子, 甚至可以用来制成培养皿来饲养细胞, 后世的生物医学工程师称之为生物相容性很好; 二是眼球内血液和其他液体比如房水和玻璃体是分隔开的, 有血房水屏障, 这种屏障阻挡了免疫反应, 所以眼内也是一个免疫豁免的区域. 这两个因素在Cleaver上尉眼睛遇到了一起, 于是PMMA弹片没有产生排异反应. 他的左眼总算是保住了.&lt;/p&gt;
&lt;p&gt;战时的临床工作忙得不可开交, Ridley医生弹片留在眼睛里的原委以后, 就记录在笔记本上, 又去忙其他病人了.&lt;/p&gt;
&lt;h3&gt;John Pike&lt;sup id="fnref-3"&gt;&lt;a class="footnote-ref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fn-3"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/h3&gt;
&lt;p&gt;二战已经结束3年多了, John Pike现在是伦敦Rayner公司的光学专家. 最近他正在和Ridley医生合作研发电子眼底镜. 研发工作进展很顺利, 他也和Ridley医生成为好朋友.&lt;/p&gt;
&lt;p&gt;一天傍晚Ridley医生打来电话, 很兴奋地说要讨论一个新项目, 还挺急, 说查房完了就过来. 在卡文迪许广场上, John Pike坐在Ridley医生的车里, 听完了8年前病例报告. Ridley医生说他打算用Perspex做一枚透镜植入到病人眼睛里, 替代天然的晶状体. John Pike觉得这事在医学上有点异想天开, 但在光学上并不困难, 不过是制造一个小一点的透镜而已. 在车里, 两个人就已经完成了大部分的设计. 这个就叫做人工晶体Intraocular lens吧.&lt;/p&gt;
&lt;p&gt;回去以后John Pike很快就按照设计制造出了样品.&lt;/p&gt;
&lt;p&gt;&lt;img alt="https://www.rayner.com/en/history" src="https://www.rayner.com/skin/frontend/mtcolias/default/images/iol_box.jpg"&gt;
https://www.rayner.com/en/history&lt;/p&gt;
&lt;h3&gt;Harold Ridley&lt;/h3&gt;
&lt;p&gt;1949年11月29日, 第一例人工晶体植入手术终于完成了. Ridley医生从圣托马斯医院办公室的窗户看着泰晤士河上往来的船只, 心中有些激动.&lt;/p&gt;
&lt;p&gt;这是一个49岁&lt;sup id="fnref-4"&gt;&lt;a class="footnote-ref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fn-4"&gt;4&lt;/a&gt;&lt;/sup&gt;的女病人名叫伊丽莎白, 她的左眼晶状体已经完全浑浊, Pike或者说Rayner公司生产的人工晶体被植入到了患者眼内. 巡台护士Doreen Clarke小姐配合得不错, 手术视野照明很清楚. 当时并没有手术显微镜, Clarke小姐用的是一把手电. 术后, Clarke小姐在记录本上记下了"Extra-capsular ext"--白内障囊外摘除术.&lt;/p&gt;
&lt;p&gt;但其实第一例手术并不算顺利, 而且这也是第一例人工晶体手术并发症----度数算错了, 术后病人验光有高度近视, 但视力仍然提高到20/60.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Ridley's eighth IOL implantation, performed at St. Thomas' Hospital, May 8, 1951" src="https://i.loli.net/2018/06/01/5b1036f8abdf1.png"&gt;
(https://www.rayner.com/media/pdf/Invention_of_the_IOL.pdf)&lt;/p&gt;
&lt;p&gt;之后, Ridley医生又做了很多人工晶体植入手术, 早期的手术大约有70%的成功率. 虽然白内障病人多数是老年人, 但也有一些年轻的病人因为外伤植入人工晶体, 这些病人经过了40多年后, 仍然保持着可用的视力. &lt;sup id="fnref-5"&gt;&lt;a class="footnote-ref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fn-5"&gt;5&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h3&gt;Gordon Cleaver&lt;/h3&gt;
&lt;p&gt;Cleaver上尉因为在温切斯特保卫战中的英勇表现被授予空军功勋十字勋章, 当时他年仅30岁, 但右眼失明, 左眼破裂伤使得他无法再驾驶战斗机重回蓝天.&lt;/p&gt;
&lt;p&gt;在他70多岁的时候, 他的左眼晶状体也终于出现了白内障, 他也接受了白内障摘除手术, 并植入了一枚人工晶体. &lt;/p&gt;
&lt;h3&gt;Harold Ridley&lt;/h3&gt;
&lt;p&gt;2000年2月, Ridley医生被英女王授予爵士勋衔(Knight Bachelor), 以表彰他在白内障手术中的开创性工作.&lt;/p&gt;
&lt;p&gt;Harold Ridley爵士逝世于2001年5月25日, 享年94岁.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://images-na.ssl-images-amazon.com/images/I/51udsOifu8L._SX398_BO1,204,203,200_.jpg"&gt;&lt;/p&gt;
&lt;!-- EOF --&gt;

&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-1"&gt;
&lt;p&gt;https://en.wikipedia.org/wiki/Gordon_Cleaver &lt;a class="footnote-backref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fnref-1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-2"&gt;
&lt;p&gt;https://en.wikipedia.org/wiki/Harold_Ridley_(ophthalmologist) &lt;a class="footnote-backref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fnref-2" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-3"&gt;
&lt;p&gt;https://en.wikipedia.org/wiki/Rayner_(company) &lt;a class="footnote-backref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fnref-3" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-4"&gt;
&lt;p&gt;维基百科上说年龄是45岁, 但按照"Sir Harold Ridley and His Fight for Sight"中的记录, 还是应当为49岁. &lt;a class="footnote-backref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fnref-4" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn-5"&gt;
&lt;p&gt;&lt;a href="https://www.sciencedirect.com/science/article/pii/S0886335099800613"&gt;Letocha, C. E.; Pavlin, C. J. (1999). "Follow-up of 3 patients with Ridley intraocular lens implantation". Journal of cataract and refractive surgery. 25 (4): 587–591.&lt;/a&gt; &lt;a class="footnote-backref" href="https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/#fnref-5" title="Jump back to footnote 5 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>IOL</category><category>ophthalmology</category><guid>https://goldengrape.github.io/posts/bulabula/stories_of_IOL_1/</guid><pubDate>Thu, 31 May 2018 17:00:00 GMT</pubDate></item><item><title>描红字帖</title><link>https://goldengrape.github.io/posts/bulabula/copybook-for-shufa/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;练毛笔字, 自觉练习进度缓慢, 于是决定采用训练神经网络的方式训练神经. 假设人脑具有足够强的泛化能力, 那么训练的最优策略就是用重复数据强化训练, 先迅速达成过拟合, 然后睡上一觉可能就自动调优了.&lt;/p&gt;
&lt;p&gt;一个意外的发现, 激光打印机是可以打印宣纸的, 只要把宣纸裁剪成A4纸接近的大小, 按长轴折上一两次, 然后送进打印机, 就可以打印了. 当然容易卡纸, 发生率在10%~20%左右. 卡纸了以后小心取出来就是, 目前还没有碎在打印机里.&lt;/p&gt;
&lt;p&gt;于是我自制了一个描红字帖.
&lt;!-- TEASER_END --&gt;&lt;/p&gt;
&lt;p&gt;我的练习用宣纸, 折叠两次后大约是17cm X 35cm, 于是我按照这个尺寸做的字帖, 第一列是减淡后的原字, 第二列是笔画的骨架, 第三列是空白.&lt;/p&gt;
&lt;p&gt;示例是这样的:
&lt;img alt="字帖骨架" src="https://i.loli.net/2018/05/26/5b098168f1dc8.jpg"&gt;&lt;/p&gt;
&lt;p&gt;每个字先贴进PowerPoint, 然后用"删除背景"将字体背景去掉, 调成适当大小后每6个字一组合, 组合之后另存为图片, 就有了第一列的图, 然后用skimage里的skeletonize把骨架生成出来, 注意这仅仅是从笔画外形得出的骨架, 如果两笔有重叠还是分不出来的, 只能作为提示用,&lt;/p&gt;
&lt;p&gt;生成字体骨架的代码如下:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;skimage.morphology&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;skeletonize&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;skimage&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;io&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;ske&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;file_extension&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;splitext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;)[:,:,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;
    &lt;span class="n"&gt;skeleton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;skeletonize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;ske&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;skeleton&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;skeleton&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;out_name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"ske_"&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s2"&gt;".png"&lt;/span&gt;
    &lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imsave&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;out_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ske&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;最后再做成一个PowerPoint文件, 手工制作, 所以只做了几页, 够我练习一阵了. &lt;a href="https://mega.nz/#!rDhinKzb"&gt;下载此文件. &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;强化训练的时候, 就可以翻来覆去地写了, 比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从左到右, 按行来写;&lt;/li&gt;
&lt;li&gt;从左到右, 按列来写;&lt;/li&gt;
&lt;li&gt;从右到左, 按行来写;&lt;/li&gt;
&lt;li&gt;从右到左, 按列来写.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一张宣纸裁出的四张正好写完.&lt;/p&gt;
&lt;!-- EOF --&gt;&lt;/div&gt;</description><category>Art</category><guid>https://goldengrape.github.io/posts/bulabula/copybook-for-shufa/</guid><pubDate>Sat, 26 May 2018 15:00:00 GMT</pubDate></item><item><title>眼科数据随机森林</title><link>https://goldengrape.github.io/posts/python/random-forest-for-ophthalmology-data/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;要讲解"随机森林", 先要简介一下"决策树". 各位眼科大夫在眼科门诊每天都在用"决策树", 比如一位单侧眼痛伴同侧头痛的病人进入门诊:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;眼压&amp;gt;21mmHg吗?&lt;ul&gt;
&lt;li&gt;不是, 考虑其他可能&lt;/li&gt;
&lt;li&gt;是的, 考虑青光眼可能, 还有鉴别诊断1, 2, 3..., 进入下一题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;前房浅吗?&lt;ul&gt;
&lt;li&gt;不是, 考虑其他可能&lt;/li&gt;
&lt;li&gt;是的, 考虑急性闭角型青光眼发作, 还有鉴别诊断x,y,z...,, 进入下一题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;瞳孔光反射存在吗?&lt;ul&gt;
&lt;li&gt;存在, 考虑其他可能&lt;/li&gt;
&lt;li&gt;瞳孔固定, 考虑急性闭角型青光眼发作, 进入下一题
. . . .&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这就是一颗"决策树", 就是一堆判断题, 一层一层筛选, 最终将数据(病人)分成几类(急闭, 其他)&lt;/p&gt;
&lt;p&gt;"随机森林"就是由一组这样的"决策树"组成的分类器.
&lt;!-- TEASER_END --&gt;&lt;/p&gt;
&lt;h2&gt;随机森林的优劣&lt;/h2&gt;
&lt;h3&gt;优点就是简单好用:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;它对输入的数据没什么特殊要求, 不需要很严格的预处理, 比如不需要归一化, 不需要正态分布化. 定量的数据也行, 定性的数据也行. 完全不挑食.&lt;/li&gt;
&lt;li&gt;它得到模型预测准确率还不差, 甚至使用默认参数也不差. 如果用同样的数据集实验, 不用深度学习的话. 随机森林的准确率大概可以排进前三.&lt;/li&gt;
&lt;li&gt;需要的数据量和运算量, 都还是在可接受范围内, 比如一两百个的数据, 用笔记本电脑跑上几分钟, 也许就能给出不错的结果.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;缺点:&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;结果不好解释. 不过大概除了线性模型, 哪个机器学习出来的结果都不好解释.&lt;/li&gt;
&lt;li&gt;还是属于"传统"的机器学习方法. 有些太复杂的问题还是需要深度学习来做.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以, 个人意见是遇到问题先用随机森林试试呗, 不好再换深度学习.&lt;/p&gt;
&lt;h2&gt;随机森林代码&lt;/h2&gt;
&lt;p&gt;通过python scikit-learn建立并且训练一个随机森林模型的代码非常好写, 实际上只有两句话:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;clf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RandomForestClassifier&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;clf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X_train&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y_train&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;比较复杂的是如何标记数据, 如何把数据读取进来, 如何把数据整理清洗拆分. . .  干些体力活, 得到X_train, y_train这两个东西.&lt;/p&gt;
&lt;p&gt;程序世界的好处是, 体力活大多只需要干一次, 做好模板, 以后就轻松了. 所以我就在这里把眼科这部分的脏活累活先做好.&lt;/p&gt;
&lt;p&gt;目前支持的有医疗设备已经有:
&lt;em&gt; &lt;a href="http://www.zeaomed.com/jmdxty/772.html"&gt;Sirius角膜地形图&lt;/a&gt;
&lt;/em&gt; &lt;a href="https://www.pentacam.com/int/ophthalmologist-with-pentacam.html"&gt;PentaCam角膜地形图&lt;/a&gt;
&lt;em&gt; &lt;a href="http://www.wiskeymedical.com.cn/product/v1049"&gt;Grand Seiko WAM5500视调节力测量仪&lt;/a&gt;
&lt;/em&gt; &lt;a href="https://www.zeiss.com.cn/meditec/products/ophthalmology-optometry/glaucoma/diagnostics/perimetry/humphrey-field-analyzer-3.html"&gt;Humphrey视野(PDF需预先处理)&lt;/a&gt;
* &lt;a href="http://www.gvchina.com/product.aspx?t=1&amp;amp;c=12"&gt;HRT(PDF需预先处理)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开源项目已经&lt;a href="https://github.com/goldengrape/read_medical_device_data"&gt;放在github上&lt;/a&gt;,
推荐通过&lt;a href="https://goldengrape.github.io/posts/python/random-forest-for-ophthalmology-data/notebooks.azure.com"&gt;微软的azure notebooks&lt;/a&gt;在线使用, 使用azure notebook的教程, 请参考&lt;a href="https://goldengrape.github.io/Python-for-ophthalmologist/"&gt;这篇教程&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;眼科数据随机森林模型的使用方法&lt;/h2&gt;
&lt;h3&gt;上传数据&lt;/h3&gt;
&lt;p&gt;如果你用的是微软azure notebooks, 那么在clone本项目以后, 可以设定成私有项目, 这样再传数据的时候, 不至于泄露给其他人. 你需要用浏览器在云端建立一个目录, 然后把医疗设备的数据报告一个一个上传上去, 看网速吧.&lt;/p&gt;
&lt;p&gt;如果你已经有能力在本地运行python, 甚至装好了anaconda,pandas,scikit-learn, 那无需太多解释, 你只需要把数据放在程序能够找到的路径里即可.&lt;/p&gt;
&lt;h3&gt;PDF数据预处理:&lt;/h3&gt;
&lt;p&gt;目前能够处理的是HRT和Humphrey视野计两种PDF报告, 找到python/pdf_parser目录,&lt;/p&gt;
&lt;p&gt;分别按照HRT.ipynb和Humphrey_VF.ipynb文件中的要求, 修改好路径, 运行. PDF文件的报告会被转换成csv文件.&lt;/p&gt;
&lt;p&gt;csv文件是"逗号分割的"电子表格文件, 可以方便使用excel编辑或者查看, 记得编辑完成后使用"另存为"csv文件.&lt;/p&gt;
&lt;h3&gt;class.csv文件设定&lt;/h3&gt;
&lt;p&gt;需要使用excel编辑这样一个表格, 示例请见\testdata\class.csv
&lt;img alt="屏幕快照 2018-05-14 22.21.30" src="https://i.loli.net/2018/05/14/5af99ba24ed2d.png"&gt;
第一列是class, 记录每一行所代表的病人的诊断, 有病/没病, 也可以有多个诊断.&lt;/p&gt;
&lt;p&gt;之后的每个单元格里填入的是该病人的数据文件名, 其中列标题要注明是哪种设备. (注意大小写, 业余作品不要太挑拣)&lt;/p&gt;
&lt;h3&gt;分析项目设定&lt;/h3&gt;
&lt;p&gt;需要使用excel再编辑一个表格, 示例请见\testdata\analysis_category.csv&lt;/p&gt;
&lt;p&gt;&lt;img alt="屏幕快照 2018-05-14 22.31.13" src="https://i.loli.net/2018/05/14/5af99df6d5270.png"&gt;&lt;/p&gt;
&lt;p&gt;列标题是设备的名称, 每个单元格里是需要分析该设备数据文件中的哪些项目, 项目的名称在各个设备的json中找, (注意大小写, 业余作品不要太挑拣)&lt;/p&gt;
&lt;p&gt;GrandSeikoWAM5500中的项目有:
&lt;em&gt; date: 检查时间
&lt;/em&gt; start_time: 检查开始时间
&lt;em&gt; eye: 眼别
&lt;/em&gt; time: 测量时间点
&lt;em&gt; power: 屈光状态
&lt;/em&gt; pupil: 瞳孔直径&lt;/p&gt;
&lt;p&gt;HRT中的项目有:
&lt;em&gt; "DOB": 出生日期, 操作员不一定都好好填的
&lt;/em&gt; "sex": 性别
&lt;em&gt; "date": 检查时间
&lt;/em&gt; "OS_data":左眼数据
&lt;em&gt; "OD_data":右眼数据
&lt;/em&gt; "Asymmetry_data": 非对称数据
* "classifiction": HRT设备给出的分类诊断, (不建议包含)&lt;/p&gt;
&lt;p&gt;humphrey视野计的项目有:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"DOB":生日,&lt;/li&gt;
&lt;li&gt;"eye": 眼别&lt;/li&gt;
&lt;li&gt;"date":检查日期&lt;/li&gt;
&lt;li&gt;"False POS Errors":假阳性&lt;/li&gt;
&lt;li&gt;"False NEG Errors":假阴性, 这两个是判定视野检查质量的&lt;/li&gt;
&lt;li&gt;"VFI": 忘了是啥了.&lt;/li&gt;
&lt;li&gt;"MD": 平均缺损, 有重要随访意义&lt;/li&gt;
&lt;li&gt;"PSD": 又忘了是啥了&lt;/li&gt;
&lt;li&gt;"data": 这是二维的视野数据, 在送进随机森林的时候, 会抻成一列使用, 所以左右眼的排布会是不同的.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pentacam角膜地形图:
"FRONT", "BACK", "Cornea", "Pachy", "Chamber","K",
"Pupil", "X", "Y"
注意, 这些数据里大多也是二维数据, 将抻成一维使用, 左右眼可能会有不同.&lt;/p&gt;
&lt;p&gt;sirius 角膜地形图:
&lt;em&gt; "Radii":,
&lt;/em&gt; "CornealThickness":,
&lt;em&gt; "ElevationAnterior":,
&lt;/em&gt; "ElevationPosterior":,
&lt;em&gt; "RefractiveEquivalentPower":,
&lt;/em&gt; "RefractiveFrontalPowerAnterior":,
&lt;em&gt; "RefractiveFrontalPowerPosterior":,
&lt;/em&gt; "SagittalAnterior":,
&lt;em&gt; "SagittalPosterior":,
&lt;/em&gt; "TangentialAnterior":,
* "TangentialPosterior":
这里面数据好多, 也是注意二维数据的问题, 要注意左右眼的问题.&lt;/p&gt;
&lt;h3&gt;运行随机森林模型&lt;/h3&gt;
&lt;p&gt;随机森林模型在python/random_forest_model.ipynb, 如果设定好class.csv和analysis_category.csv, 大概就不需要什么修改,可以直接训练了,&lt;/p&gt;
&lt;p&gt;训练完成后要观察一下ROC曲线和AUC评分. ROC曲线越靠近左上越好, AUC评分越接近1越好. 在该文件中, 我也有说明如何进行进一步的参数调节和优化. 但, 如果AUC评分巨高就直接发文章好了, 如果AUC评分接近0.5, 就算了吧, 换深度学习方式好了.&lt;/p&gt;
&lt;p&gt;最后, 这是一个业余项目, 代码并不完善, 还在缓慢而持续地改进中.  &lt;/p&gt;
&lt;!-- EOF --&gt;&lt;/div&gt;</description><category>ophthalmology</category><category>python</category><category>现代眼科医生知识扩展包</category><guid>https://goldengrape.github.io/posts/python/random-forest-for-ophthalmology-data/</guid><pubDate>Mon, 14 May 2018 14:00:00 GMT</pubDate></item><item><title>Applied Data Science with Python Specialization小结</title><link>https://goldengrape.github.io/posts/bulabula/Applied-Data-Science-with-Python-Specialization-summary/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://www.coursera.org/specializations/data-science-python"&gt;Applied Data Science with Python Specialization&lt;/a&gt;
五张证书拿到.&lt;/p&gt;
&lt;p&gt;小结一下这几门课
&lt;!-- TEASER_END --&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第1门. Introduction to Data Science in Python
讲Pandas基础, 严重推荐, 必学必会.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第2门. Applied Plotting, Charting &amp;amp; Data Representation in Python
讲Matplotlib绘图, 严重推荐, 必学必会&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第3门, Applied Machine Learning in Python
讲scikit learn, 严重不推荐, 建议上youtube随便找找教程也比那个老师讲得好,
理解一下ROC, 知道如何评估模型.
传统机器学习学会随机森林一项即可, 遇到问题一切默认参数先来一把梭, 效果不好就换深度学习了, 不要浪费时间.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第4门, Applied Text Mining in Python
讲NLTK, 如果有处理自然语言的需求可以学学, 普通大众意义不大. 老师幽默风趣, 印度口音十足, 可供练习听力.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第5门, Applied Social Network Analysis in Python
讲networkX, 推荐, 生物医学化学领域推荐学习, 以此为基础再听听图论可能更佳.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在图像之外的领域, 手工提取feature的技能还是有意义的, 需要借鉴前人的研究基础, 比如自然语言, 图论中的很多预处理的函数, 理解其意义\用途, 很有帮助.&lt;/p&gt;
&lt;p&gt;但在模型构建和训练上, 线性/SVM/决策树之类, 与深度学习相比, 除了需要数据量略少, 其他看起来并没有什么优势.&lt;/p&gt;
&lt;p&gt;随机森林搭建省力, 可以作为基准. gbdt虽然效果类似, 但..RadomForest的名字比较好记. &lt;/p&gt;&lt;/div&gt;</description><category>python</category><guid>https://goldengrape.github.io/posts/bulabula/Applied-Data-Science-with-Python-Specialization-summary/</guid><pubDate>Mon, 16 Apr 2018 17:00:00 GMT</pubDate></item><item><title>口算复利</title><link>https://goldengrape.github.io/posts/bulabula/compute-Compound-Interest/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;这是一个常用的小技巧. 口算复利的倍增时间.&lt;/p&gt;
&lt;p&gt;$$
time=\frac{70\%}{ROI}
$$&lt;/p&gt;
&lt;p&gt;例如, 以7%的利息复利存款, 存入100元, 则大约10年后变成连本带利变成200元.&lt;/p&gt;
&lt;p&gt;证明:
&lt;!-- TEASER_END --&gt;
&lt;img alt="QED" src="https://i.loli.net/2018/04/13/5ad03d0219a8b.jpeg"&gt;&lt;/p&gt;&lt;/div&gt;</description><category>life science</category><guid>https://goldengrape.github.io/posts/bulabula/compute-Compound-Interest/</guid><pubDate>Fri, 13 Apr 2018 04:00:00 GMT</pubDate></item><item><title>智能家电与不在场证据</title><link>https://goldengrape.github.io/posts/bulabula/Smart-home-and-evidence-of-absence/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;常常有人吐槽各种智能家电的"智能"其实很无用, 本来就是一个开关, 不过是挪动到了手机上.&lt;/p&gt;
&lt;p&gt;我这里提出一个评估方法:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;智能家电的智能程度, 与其所能够提供"不在场证据"强度成反负相关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- TEASER_END --&gt;

&lt;p&gt;以洗衣服为例. 假设有目击证人看到早上8点嫌疑人拿了10件很脏的衬衫回去洗, 24后嫌疑人又被看到拿这10件洗干净的衬衫出现. 犯罪现场距离嫌疑人家中1小时车程的位置. 犯罪a,b,c分别发生在11点, 12点, 13点.&lt;/p&gt;
&lt;p&gt;已知为了晾干衣服, 至少要在1pm前将衣服晾在阳台.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有棒槌洗衣.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;嫌疑人至少要花费4小时手工洗衣, 为了能够在第二天8点前取得晾干的衬衫. 那么嫌疑人8点开始洗衣服, 洗完已经是12点, 完全没有作案时间. 此时棒槌洗衣机能够提供完全的"不在场证据".&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用加酶洗衣粉.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;嫌疑人需要花费2小时浸泡衣物, 但只需要手洗1小时即可将衣服洗干净. 嫌疑人8点开始浸泡衣物, 但浸泡上以后, 8点到10点可以不在衣物旁边, 有作案准备时间, 然后可以在10点至12点的任意时间开始手洗衣服, 都可以赶在1pm前开始晾衣服. 此时没有8点到10点的不在场证明, 在10点至12点内只有1小时的不在场证明, 且开始时间不定.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要手工启动的无烘干洗衣机&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;洗衣机洗衣服需要1小时, 嫌疑人可以在8点至12点的任意时间点开始启动洗衣机, 然后可以离开家, 但必须在1pm前回到家中将衣服从洗衣机中取出晾晒. 于是可以确定的是8点到12点至少有一次在家, 1pm前至少有一次在家.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要手工启动的有烘干洗衣机&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;嫌疑人需要将衣服放进洗衣机, 所以8点后至少回到家一次, 一旦启动洗衣机就不必再管, 所以8点01分就不能保证嫌疑人是在家的了.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够自动取送衣服, 自动放入洗衣机的, 能够远程启动的有烘干功能洗衣机&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;嫌疑人不必回家, 嫌疑人可以出现在任何地方不受限制.&lt;/p&gt;
&lt;p&gt;综上, 机器工作的过程有多长时间, 多复杂并不用考虑, 需要考虑的是能够连续多长时间不需要在特定地点操作机器.&lt;/p&gt;
&lt;!-- EOF --&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/bulabula/Smart-home-and-evidence-of-absence/</guid><pubDate>Tue, 10 Apr 2018 14:00:00 GMT</pubDate></item><item><title>用Fusion360编辑STL</title><link>https://goldengrape.github.io/posts/bulabula/edit-STL-with-Fusion360/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;STL文件就像是PDF, 是面向打印机的. 难以编辑. 即使能够编辑, 面对大量的三角形, 运行速度也非常慢.&lt;/p&gt;
&lt;p&gt;不过最近总算找到了用Fusion360的一点点技巧.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;要打开首选项-&amp;gt;预览-&amp;gt;"网格"工作空间
&lt;img alt="" src="https://i.loli.net/2018/04/03/5ac2756be46a2.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入网格, 或者使用"上传"STL文件.
&lt;img alt="插入网格" src="https://i.loli.net/2018/04/03/5ac275c903dd1.png"&gt;
&lt;img alt="插入网格2" src="https://i.loli.net/2018/04/03/5ac275c97231b.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不捕获设计历史
&lt;img alt="不捕获设计历史" src="https://i.loli.net/2018/04/03/5ac275cab7bff.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;右键选择网格对象, "Mesh到BRep", 转换成实体
&lt;img alt="Mesh到BRep" src="https://i.loli.net/2018/04/03/5ac275ca15a81.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;铛铛, 变成实体了, 可以在各个面上编辑. 但明明是一个平面, 还是被分成了很多的三角形. 很不方便, 下面才是重点.
&lt;img alt="很多三角形" src="https://i.loli.net/2018/04/03/5ac275c9e694b.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随便找一个面进行"分割实体"的操作.
&lt;img alt="分割实体" src="https://i.loli.net/2018/04/03/5ac275ca86ccb.png"&gt;
&lt;img alt="任选一个面" src="https://i.loli.net/2018/04/03/5ac275ca84e6a.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切完以后, 所有的平面突然就不再是一堆三角形了.
&lt;img alt="三角形消失" src="https://i.loli.net/2018/04/03/5ac2780923f8c.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后在使用"合并", 将切开的实体合并在一起.
&lt;img alt="合并" src="https://i.loli.net/2018/04/03/5ac2784911a66.png"&gt;
&lt;img alt="到一起" src="https://i.loli.net/2018/04/03/5ac275ca4f95b.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;成品. 平面都得到了简化, 但曲面目前还没有办法. 记得完成以后把"捕获历史"的功能在再打开.
&lt;img alt="成品" src="https://i.loli.net/2018/04/03/5ac27884f2f99.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后, 号召一下. 如果设计的3D模型仅仅以STL或者其他网格形式发布, 就请尽量少用圆角吧. 谢谢!&lt;/p&gt;&lt;/div&gt;</description><category>3D print</category><guid>https://goldengrape.github.io/posts/bulabula/edit-STL-with-Fusion360/</guid><pubDate>Mon, 02 Apr 2018 18:30:00 GMT</pubDate></item><item><title>Scikit-learn笔记4(ROC曲线)</title><link>https://goldengrape.github.io/posts/python/scikit-learn-note-4/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;a href="https://www.coursera.org/learn/python-machine-learning"&gt;Applied Machine Learning in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这门课实在是太差了. 严重差评:&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;"所谓私人恩怨，跟政治就是一回事。所以，如果有哪个白痴政客或者哪个大人物想要推行一项法令或政策，伤害到你或者你亲人朋友的利益，那就是私人恩怨。点燃你的怒火吧。" ----奎尔&lt;/p&gt;
&lt;p&gt;作为报复, 我决定把第三周的ppt给丫翻译了!&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="决策函数(decision_function)"&gt;决策函数(decision_function)&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-4/#%E5%86%B3%E7%AD%96%E5%87%BD%E6%95%B0(decision_function)"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分类器对每个测试点都给出一个分数, 这个分数表示分类器预测的可信度. &lt;/li&gt;
&lt;li&gt;选择一个固定的决策阈值就给出了一个分类规则. (大于阈值的就是正分类, 小于阈值的就是负分类)&lt;/li&gt;
&lt;li&gt;通过改变决策阈值, 在所有可能的分数范围内扫描, 我们就可以给出给出一个曲线&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="预测属于某个分类的概率(predict_proba)"&gt;预测属于某个分类的概率(predict_proba)&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-4/#%E9%A2%84%E6%B5%8B%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%88%86%E7%B1%BB%E7%9A%84%E6%A6%82%E7%8E%87(predict_proba)"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;典型的规则: 选择最可能的分类
例如: 如果数值&amp;gt;0.5, 属于分类1&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过改变阈值可以调节分类器的预测. &lt;/li&gt;
&lt;li&gt;更高的阈值导致更为保守的分类器&lt;ul&gt;
&lt;li&gt;例如只有数值&amp;gt;0.7才归入分类1&lt;/li&gt;
&lt;li&gt;高阈值增加了precision. 比之前低阈值时更少把样本归入分类1, 但是如果归入到样本1, 那么把握更大. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;还是举个我更熟悉的例子吧, 比如仅仅用眼压作为青光眼的诊断标准,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;21mmHg就是一个阈值, &lt;/li&gt;
&lt;li&gt;大于21mmHg的就归入青光眼分类, 小于等于21mmHg的就归入正常眼的分类. 但显然这样会把一部分高眼压症的人算作是青光眼. &lt;/li&gt;
&lt;li&gt;如果把阈值提高到比如30mmHg, 那么筛出来的病人, 真正就是青光眼的可能性就要高很多. 就是Precision更高. &lt;/li&gt;
&lt;li&gt;如果把阈值降低到比如15mmHg, 那么就有更少的病人漏网, 也就是Recall更高&lt;/li&gt;
&lt;li&gt;后面会讲半天ROC曲线, 就是看阈值变化时, Precision和Recall的变化. &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;del&gt;但是! 在此处吐槽一下. 这样的分类方法明显是错的啊, 本来根本不是用一个值来简单区分的事情, 为什么要强行这么做? 要诊断青光眼还要看视盘, 看盘沿, 看视野, 看动态变化, 本来就不是一个一维的事情, 不管其他, 去找一个参数的分界线是不对的啊. &lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;_贱人就是矫情_&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;(4月4日更正), 此处的吐槽是不对的, 很抱歉. decision_function可以用到不同的分类器上, 是把多维的数据最终映射到一维上, 再拿到一维上来分类, 所以即使是深度学习, 如果是二分类问题, 仍然是最后由一个神经元输出[0, 1]之间的值, 并根据这个值来区分, 比如用sigmoid做激活函数, 那么分界阈值就是0.5, 但实际上可以设定不同. 所以仍然可以得出一个ROC曲线.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="再复习一下各种率"&gt;再复习一下各种率&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-4/#%E5%86%8D%E5%A4%8D%E4%B9%A0%E4%B8%80%E4%B8%8B%E5%90%84%E7%A7%8D%E7%8E%87"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src="https://goldengrape.github.io/images/ratios.png" alt=""&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;比如现在只用眼压区分青光眼, 补充一点背景知识: 已知95%的人群眼压是是10-21mmHg, 眼压最低也只能到房水的流出通道, 也就是静脉里面, 最低最低8mmHg, 眼压到30mmHg摸起来已经接近脑门的硬度了, 到40mmHg已经要疼得撞墙了.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那么, 如果以10mmHg作为分界, 认为大于10mmHg的都是青光眼, 那么几乎所有的人类都是青光眼, 于是没有任何一个青光眼病人会被漏掉. &lt;/li&gt;
&lt;li&gt;如果以40mmHg作为分界, 认为大于40mmHg的才是青光眼, 那么只有急性发作的病人才会被当作是青光眼, 这时候每筛出一个病人, 肯定就是青光眼, 不会筛出来的不是, 但会漏掉很多病人. &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="Precision-Recall曲线"&gt;Precision-Recall曲线&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-4/#Precision-Recall%E6%9B%B2%E7%BA%BF"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;X轴: Precision&lt;/li&gt;
&lt;li&gt;Y轴: Recall&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;右上顶端:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理想点&lt;/li&gt;
&lt;li&gt;Precision=1.0&lt;/li&gt;
&lt;li&gt;Recall=1.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;P-R曲线的陡峭程度很重要. 在最大Precision时, 能够达到多大的Recall.&lt;br&gt;
&lt;img src="https://i.loli.net/2018/04/01/5ac0be6b687da.png" alt="P-R_curve.png"&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="ROC曲线"&gt;ROC曲线&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-4/#ROC%E6%9B%B2%E7%BA%BF"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;X轴: False Positive Rate 假阳性率&lt;/li&gt;
&lt;li&gt;Y轴: True Positive Rate  真阳性率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;左上顶点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理想点&lt;/li&gt;
&lt;li&gt;False positive rate 假阳性率=0 &lt;/li&gt;
&lt;li&gt;True positive rate 真阳性率=1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2018/04/01/5ac0c250b9182.png" alt="ROC.png"&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;ul&gt;
&lt;li&gt;ROC曲线越往左上, 越好. &lt;/li&gt;
&lt;li&gt;曲线下面积(AUC), 越大越好&lt;/li&gt;
&lt;li&gt;45度线是随机瞎猜线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2018/04/01/5ac0c511e280e.png" alt="ROC-2.png"&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="未完待续"&gt;未完待续&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-4/#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</description><category>python</category><category>现代眼科医生知识扩展包</category><guid>https://goldengrape.github.io/posts/python/scikit-learn-note-4/</guid><pubDate>Sun, 01 Apr 2018 11:30:00 GMT</pubDate></item><item><title>Scikit-learn笔记3(各种率)</title><link>https://goldengrape.github.io/posts/python/%08scikit-learn-note-3/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;关于precision, recall的定义, 关于假阳性, 假阴性, 真阳性, 真阴性之类的定义, 我以后一定还是会忘记的.&lt;/p&gt;
&lt;p&gt;而且鉴于我以前凡是两个能够弄混的事情一定可以弄混的特性,&lt;/p&gt;
&lt;p&gt;于是把什么真假阴性阳性扩展到更多的情况, 画了张图&lt;/p&gt;
&lt;p&gt;红色是分子, 灰色是分母. (灰色区域都是包含红色的)&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://goldengrape.github.io/images/ratios.png"&gt;&lt;/p&gt;&lt;/div&gt;</description><category>python</category><category>现代眼科医生知识扩展包</category><guid>https://goldengrape.github.io/posts/python/%08scikit-learn-note-3/</guid><pubDate>Sun, 01 Apr 2018 04:00:00 GMT</pubDate></item><item><title>Scikit-learn笔记2</title><link>https://goldengrape.github.io/posts/python/scikit-learn-note-2/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div tabindex="-1" id="notebook" class="border-box-sizing"&gt;
    &lt;div class="container" id="notebook-container"&gt;

&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;&lt;a href="https://www.coursera.org/learn/python-machine-learning"&gt;Applied Machine Learning in Python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这门课实在是太差了. 严重差评:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本身讲得就很差, 还经常口误&lt;/li&gt;
&lt;li&gt;不写板书, 对着ppt念&lt;/li&gt;
&lt;li&gt;代码写得也混乱, 在函数内部用import? ? &lt;/li&gt;
&lt;li&gt;交作业的时候要手动注释掉matplotlib&lt;/li&gt;
&lt;li&gt;考试填空题是给出函数的运行结果&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;我上大学时上毛泽东思想概论和邓小平理论的课听着都比这舒坦.&lt;/p&gt;
&lt;p&gt;作为报复, 我决定把第三周的ppt给丫翻译了!&lt;!-- TEASER_END --&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="评估"&gt;评估&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#%E8%AF%84%E4%BC%B0"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不同的应用可能有非常不同的目标&lt;/li&gt;
&lt;li&gt;Accuracy虽然广泛使用, 但其他的评估指标也可能使用. 例如:&lt;ul&gt;
&lt;li&gt;用户满意度 (网络搜索)&lt;/li&gt;
&lt;li&gt;收入(电子贸易)&lt;/li&gt;
&lt;li&gt;病人生存率的提高(医疗)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="不平衡分类中的Accuracy"&gt;不平衡分类中的Accuracy&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%88%86%E7%B1%BB%E4%B8%AD%E7%9A%84Accuracy"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;假设有两个分类: &lt;ul&gt;
&lt;li&gt;相关(R): 阳性分类结果&lt;/li&gt;
&lt;li&gt;不相关(N): 阴性分类结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;随机选择1000个样本, 平均而言: Out of 1000 randomly selected items, on average&lt;ul&gt;
&lt;li&gt;1个R&lt;/li&gt;
&lt;li&gt;999个N&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
Accuracy = \frac{正确预测的数量}{总量}
$$&lt;/p&gt;
&lt;p&gt;你建了一个分类器, 在test set上测试后发现accuracy=99.9%&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wow! Amazingly good! 是不是? &lt;/li&gt;
&lt;li&gt;为了比较, 假定我们有一个"dummy"分类器, 就是个假分类器, 不管输入是什么, 都预测是最多频率的类别, 比如N&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么
$$
Accuracy_{DUMMY} = \frac{999}{1000}=99.9\%
$$&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="Dummy分类器完全忽略输入数据"&gt;Dummy分类器完全忽略输入数据&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#Dummy%E5%88%86%E7%B1%BB%E5%99%A8%E5%AE%8C%E5%85%A8%E5%BF%BD%E7%95%A5%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;scikit-learn中常用的DummyClassifier类型: &lt;ul&gt;
&lt;li&gt;most_frequent: 预测值是出现频率最高的类别&lt;/li&gt;
&lt;li&gt;stratified : 根据训练集中的频率分布给出随机预测&lt;/li&gt;
&lt;li&gt;uniform: 使用等可能概率给出随机预测&lt;/li&gt;
&lt;li&gt;constant: 根据用户的要求, 给出常数预测. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这个方法的主要动机是F1-scoring, 当阳性分类很少的情况. &lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;如果你的模型预测结果跟Dummy差不多:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能无效，错误或缺失&lt;/li&gt;
&lt;li&gt;内核或超参数选择不当&lt;/li&gt;
&lt;li&gt;分类失衡, 有的类别太多&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="重点重点:-Binary-prediction-outcomes"&gt;重点重点: Binary prediction outcomes&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#%E9%87%8D%E7%82%B9%E9%87%8D%E7%82%B9:-Binary-prediction-outcomes"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th style="text-align:left"&gt;&lt;/th&gt;
&lt;th style="text-align:left"&gt;预测为(-)&lt;/th&gt;
&lt;th style="text-align:left"&gt;预测为(+)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;实际为(-)&lt;/td&gt;
&lt;td style="text-align:left"&gt;TN&lt;/td&gt;
&lt;td style="text-align:left"&gt;FP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;实际为(+)&lt;/td&gt;
&lt;td style="text-align:left"&gt;FN&lt;/td&gt;
&lt;td style="text-align:left"&gt;TP&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;TP = true positive 真阳性&lt;/li&gt;
&lt;li&gt;FP = false positive (Type I error) 假阳性(Type I错误) , 印象里就是P&amp;lt;0.05的0.05&lt;/li&gt;
&lt;li&gt;TN = true negative 真阴性&lt;/li&gt;
&lt;li&gt;FN = false negative (Type II error)假阴性(Type II错误)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的矩阵叫做: Confusion-Matrix&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Accuracy: 分类正确的概率. 实际为(-)预测为(-), 实际为(+)预测为(+)叫做正确. 
$$
Accuracy=\frac{TP + TN}{TP + TN + FP + FN}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Classification error: (1-Accuracy), 分类错误的概率
$$
Classification\;  error=\frac{FP + FN}{TP + TN + FP + FN}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Recall, 真阳性率: 实际上为(+), 能够被预测成(+)的概率&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Recall又叫 &lt;/li&gt;
&lt;li&gt;True Positive Rate (TPR): 真阳性率&lt;/li&gt;
&lt;li&gt;Sensitivity: 敏感性&lt;/li&gt;
&lt;li&gt;Probability of detection: 检出率
$$
Recall=\frac{TP}{TP+FN}
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Precision: 如果预测为(+), 那么预测正确的概率
$$
Precision=\frac{TP}{TP+FP}
$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;False positive rate (FPR): 假阳性率, 误报率. 本来实际上是(-)的, 结果分类器报告成(+)的概率&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;又叫做: Specificity, 特异性
$$
False positive rate=\frac{FP}{TN+FP}
$$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h3 id="高precision,-低recall"&gt;高precision, 低recall&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#%E9%AB%98precision,-%E4%BD%8Erecall"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src="https://i.loli.net/2018/03/31/5abf84bf4da95.png" alt="high precision.png"&gt;
无罪推定, 抓到的坏人都是有罪的, 但也可能有很多漏网了.&lt;/p&gt;
&lt;h3 id="高recall,-低precision"&gt;高recall, 低precision&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#%E9%AB%98recall,-%E4%BD%8Eprecision"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src="https://i.loli.net/2018/03/31/5abf84c2c0a78.png" alt="high recall.png"&gt;
宁肯错杀一千, 不可放走一个.&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="precision与recall的折衷"&gt;precision与recall的折衷&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#precision%E4%B8%8Erecall%E7%9A%84%E6%8A%98%E8%A1%B7"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Recall指导的机器学习任务:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;法律搜索和法律信息提取&lt;/li&gt;
&lt;li&gt;肿瘤检测Tumor detection&lt;/li&gt;
&lt;li&gt;通常配备人类专家剔除假阳性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Precision指导的机器学习任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索引擎排序, 搜索建议&lt;/li&gt;
&lt;li&gt;文档分类&lt;/li&gt;
&lt;li&gt;很多面向用户的任务(因为用户记住错误!)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h3 id="F1-score:-结合precision与recall"&gt;F1-score: 结合precision与recall&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#F1-score:-%E7%BB%93%E5%90%88precision%E4%B8%8Erecall"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;$$
F_1=2\frac{precision \times recall}{precision+recall}=\frac{2TP}{2TP+FN+FP}
$$&lt;/p&gt;
&lt;h3 id="F-score:-更一般地将precision与recall结合成单独一个数"&gt;F-score: 更一般地将precision与recall结合成单独一个数&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#F-score:-%E6%9B%B4%E4%B8%80%E8%88%AC%E5%9C%B0%E5%B0%86precision%E4%B8%8Erecall%E7%BB%93%E5%90%88%E6%88%90%E5%8D%95%E7%8B%AC%E4%B8%80%E4%B8%AA%E6%95%B0"&gt;¶&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;$$
F_\beta=(1+\beta^2)\frac{precision \times recall}{\beta^2\times precision+recall}=\frac{(1+\beta^2)TP}{(1+\beta^2)TP+FN+FP}
$$&lt;/p&gt;
&lt;p&gt;𝛽用来调整recall vs precision之间的重要程度:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Precision-oriented users: 𝜷 = 0.5 &lt;/li&gt;
&lt;li&gt;Recall-oriented users: 𝜷 = 2&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [6]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;compute_scores&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;TN&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;FP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;FN&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Accuracy = TP + TN / (TP + TN + FP + FN)&lt;/span&gt;
    &lt;span class="c1"&gt;# Precision = TP / (TP + FP)&lt;/span&gt;
    &lt;span class="c1"&gt;# Recall = TP / (TP + FN)  Also known as sensitivity, or True Positive Rate&lt;/span&gt;
    &lt;span class="c1"&gt;# F1 = 2 * Precision * Recall / (Precision + Recall) &lt;/span&gt;
    &lt;span class="n"&gt;scores_dict&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="n"&gt;scores_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Accuracy"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TP&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;TN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TP&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;TN&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;FP&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;FN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;scores_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Precision"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TP&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TP&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;FP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;scores_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Recall"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TP&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TP&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;FN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;# Also known as sensitivity, or True Positive Rate&lt;/span&gt;
    &lt;span class="n"&gt;scores_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"F1"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;scores_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Precision"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;scores_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Recall"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scores_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Precision"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;scores_dict&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"Recall"&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; 
    
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;scores_dict&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing code_cell rendered"&gt;
&lt;div class="input"&gt;
&lt;div class="prompt input_prompt"&gt;In [5]:&lt;/div&gt;
&lt;div class="inner_cell"&gt;
    &lt;div class="input_area"&gt;
&lt;div class=" highlight hl-ipython3"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;c_matrix&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;"TN"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s2"&gt;"FP"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
          &lt;span class="s2"&gt;"FN"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"TP"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;96&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;compute_scores&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;96&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class="output_wrapper"&gt;
&lt;div class="output"&gt;


&lt;div class="output_area"&gt;

&lt;div class="prompt output_prompt"&gt;Out[5]:&lt;/div&gt;




&lt;div class="output_text output_subarea output_execute_result"&gt;
&lt;pre&gt;{'Accuracy': 0.905511811023622,
 'F1': 0.9411764705882353,
 'Precision': 0.9230769230769231,
 'Recall': 0.96}&lt;/pre&gt;
&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;
&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="未完待续"&gt;未完待续&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/python/scikit-learn-note-2/#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
</description><category>python</category><category>现代眼科医生知识扩展包</category><guid>https://goldengrape.github.io/posts/python/scikit-learn-note-2/</guid><pubDate>Sat, 31 Mar 2018 12:30:00 GMT</pubDate></item></channel></rss>