<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GoldenGrape's Blog (关于文章 公理设计)</title><link>https://goldengrape.github.io/</link><description></description><atom:link href="https://goldengrape.github.io/categories/gong-li-she-ji.xml" rel="self" type="application/rss+xml"></atom:link><language>zh_cn</language><copyright>Contents © 2019 &lt;a href="mailto:https://twitter.com/goldengrape"&gt;Golden Grape&lt;/a&gt; </copyright><lastBuildDate>Thu, 18 Jul 2019 13:34:35 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>公理设计笔记（4）</title><link>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;所以“公理设计”，就是基于两个公理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大化功能模块的独立性&lt;/li&gt;
&lt;li&gt;最小化信息量（～=最大化成功实施的可能性）&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;这样做的好处：&lt;/p&gt;
&lt;h2 id="甲方总是善变的"&gt;甲方总是善变的&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/#%E7%94%B2%E6%96%B9%E6%80%BB%E6%98%AF%E5%96%84%E5%8F%98%E7%9A%84"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;客户需求就是用来不断改变的，就是用来不断折腾乙方的，因为甲方通常也不知道到底要什么，得折腾几次试试看，才能明确目标。如果把搜索引擎看作是乙方，这跟搜索个信息是一样的，搜索就是个学习的过程，一开始的时候往往我也不知道搜索什么，搜几个词试过以后才能明确到底要找什么。我当过甲方也当过乙方，我知道大家都是地球人，客户需求就是个不断变化的过程。&lt;/p&gt;
&lt;p&gt;但deadline是不变的。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;如果能够一开始把FRs(功能需求)和DPs(设计参数)独立得很好，那么已经做过的事情就不算完全浪费，还有可重用的可能性。独立性越高，浪费的工作就越少。&lt;/p&gt;
&lt;p&gt;而如果各个功能模块一开始就搅合在一起，那需求改了，就只好从头开始了。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2019/07/18/5d3071310697641566.png" alt="MFE 594 An Introduction to Axiomatic Design Part 4-qURM1A1BZJw-0001.png"&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="面向对象与结构化"&gt;面向对象与结构化&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我最早学计算机语言的时候，还是结构化编程的时代，后来才开始面向对象编程。我其实一直尽量躲避面向对象编程。一部分是因为我只是做些科学计算，多数情况下一个东西算一遍就完了，不需要建立同一个类的多个实体；另一部分原因是因为设定类这事太“艺术”了，我不知道应该怎么设定，比如一个光路追踪的程序，是把光线设一个类，还是把界面设一个类，还是光线和界面都设定成类。&lt;/p&gt;
&lt;p&gt;《公理设计》这本书中专门有一章讲面向对象的软件设计，我还要再仔细看看这部分。争取能再深入理解一些。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="创新发明的套路"&gt;创新发明的套路&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/#%E5%88%9B%E6%96%B0%E5%8F%91%E6%98%8E%E7%9A%84%E5%A5%97%E8%B7%AF"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;发明是有套路的，作为发明家我知道一些。这里又提供了一组思路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果现有技术中有耦合的部分，看看能否解耦合？&lt;/li&gt;
&lt;li&gt;现有技术中的FRs(功能需求)是否满足“不重复不漏项”的原则？&lt;/li&gt;
&lt;li&gt;重新在不同的域上划分不同层级的FRs(功能需求)&lt;/li&gt;
&lt;li&gt;新的技术/其他领域的技术是否可以突破现有的约束条件？&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>公理设计</category><guid>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/</guid><pubDate>Thu, 18 Jul 2019 12:00:00 GMT</pubDate></item><item><title>公理设计笔记（3）</title><link>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_3/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;前面讲解了目的，要尽量形成FRs（功能需求）与DPs(设计参数）的解耦合对应关系&lt;/p&gt;
&lt;p&gt;尽量对角矩阵形成：
$$
FRs=\begin{bmatrix}
X &amp;amp; 0 &amp;amp; ... &amp;amp; 0
\\ 0 &amp;amp;  X &amp;amp; ... &amp;amp; 0
\\ ...
\\ 0 &amp;amp;  0 &amp;amp; ... &amp;amp; X
\end{bmatrix} DPs
$$&lt;/p&gt;
&lt;p&gt;或者至少形成三角形矩阵：
$$
FRs=\begin{bmatrix}
X &amp;amp; 0 &amp;amp; ... &amp;amp; 0
\\ X &amp;amp;  X &amp;amp; ... &amp;amp; 0
\\ ...
\\ 0 &amp;amp;  X &amp;amp; ... &amp;amp; X
\end{bmatrix} DPs
$$&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;实际过程中是分层级对FRs（功能需求）与DPs(设计参数）进行分解的。先从&lt;/p&gt;
$$
\begin{bmatrix}
FR_1
\\ FR_2
\end{bmatrix}
=
\begin{bmatrix}
X &amp;amp; 0 
\\ X &amp;amp;  X 
\end{bmatrix} 
\begin{bmatrix}
DP_1
\\ DP_2
\end{bmatrix}
$$&lt;p&gt;开始，&lt;/p&gt;
&lt;p&gt;然后再把$FR_1$（功能需求）拆解成$FR_{1.1}, FR_{1.2}$，变成类似这个意思：&lt;/p&gt;
$$
\begin{bmatrix}
\begin{bmatrix}
FR_{1.1}
\\ FR_{1.2}
\end{bmatrix}
\\ FR_2
\end{bmatrix}
=
\begin{bmatrix}
\begin{bmatrix}
X &amp;amp; 0
\\ X &amp;amp; X
\end{bmatrix}&amp;amp; 0 
\\ X &amp;amp;  X 
\end{bmatrix} 
\begin{bmatrix}
\begin{bmatrix}
DP_{1.1}
\\ DP_{1.2}
\end{bmatrix}
\\ DP_2
\end{bmatrix}
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在拆分FRs（功能需求）的时候，要求是&lt;a href="https://zh.wikipedia.org/zh-hans/MECE%E5%8E%9F%E5%88%99"&gt;MECE&lt;/a&gt; min原则，也就是"不重复不漏项"并且总数尽量少。MECE := Mutually Exclusive Collectively Exhaustive，课程中使用的是CEME，可能商科里用MECE更多，反正一个意思。&lt;/p&gt;
&lt;p&gt;比如3D打印机的FR(功能需求)之一是要求在$FR_1$打印头空间内移动，那么就可以拆分成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$FR_{1.1}$ 在X轴方向移动&lt;/li&gt;
&lt;li&gt;$FR_{1.2}$ 在Y轴方向移动&lt;/li&gt;
&lt;li&gt;$FR_{1.3}$ 在Z轴方向移动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样的拆分方式显然是MECE的，当然也可以拆分成圆柱坐标系、球坐标系等等。不同的分解方式对应着不同的解决方案。&lt;/p&gt;
&lt;p&gt;对于DPs(设计参数)的拆分，目的是尽量形成对角矩阵，或者至少是三角形矩阵，那么就应当尽量让右上角的区域保持为0。而且在拆分DPs(设计参数)的时候，约束条件是继承的，比如$DP_1$是在中国建厂，那么$DP_{1.1},DP_{1.2}$就不能把工厂建立到越南去。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在实际操作中，拆分是一点一点来进行的。说叫ZigZag。&lt;/p&gt;
&lt;p&gt;先把$FR_1$（功能需求）拆解成$FR_{1.1}, FR_{1.2}$，拆分好$FR_1$（功能需求）以后，再去拆分$DP_1$(设计参数)，拆好了DPs(设计参数)以后，再返回来拆下一个$FR$（功能需求）&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2019/07/18/5d3030b9d457e37686.png" alt="屏幕快照 2019-07-18 16.40.58.png"&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;拆分过程可以用个电子表格来做，最好再弄成可折叠的，似乎有专用的软件可以画图，但不知道excel或者其他通用的简单工具有没有这样的功能。注意子节点上的相关性X，一定要表现在父节点上。比如检查时发现调整$DP_{2}$时$FR_{12}$也跟着变，那$DP_{2}$其实与$FR_1$就是耦合的，中间肯定在某个步骤出错了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th style="text-align:left"&gt;FRs&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_1$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{11}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{12}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{121}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{122}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{123}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{2}$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_1$&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{11}$&lt;/td&gt;
&lt;td style="text-align:left"&gt;$\space$&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{12}$&lt;/td&gt;
&lt;td style="text-align:left"&gt;$\space$&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{121}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{122}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{123}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{2}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;当有几个不同的拆分FRs(功能需求)的方法，得到了不同的DPs(设计参数)以后。如何判定那种方式更好呢？毫无疑问会陷入到办公室争吵中。&lt;/p&gt;
&lt;p&gt;公理设计的第二条公理：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;要令信息量最小&lt;/p&gt;
&lt;/blockquote&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;这里的信息量，是原教旨的信息量。记住这是MIT教授的书，WPI教授的课。&lt;/p&gt;
$$
I=-\sum_{i}^{\sigma(\mathrm{FR})} \log _{2} P_{i}
$$&lt;p&gt;其中$P_i$是$FR_i$实现的概率&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在我理解，这只是实现概率最大化的恐怖公式表达而已。这一部分我还没有深究，毕竟我能想到一组DPs(设计参数)就已经不错了。&lt;/p&gt;
&lt;p&gt;这个公理大约对硬件选型的时候更有意义，比如同一个目的，在资金约束条件下，要选精度高一点，冗余大一点的零件。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>公理设计</category><guid>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_3/</guid><pubDate>Thu, 18 Jul 2019 02:00:00 GMT</pubDate></item><item><title>公理设计笔记（2）</title><link>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;如同商学院说事一定要画四格表，工学院说事一定要写向量和矩阵的。这种表述就是工科癖好。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;有四个域（Domain）：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;ul&gt;
&lt;li&gt;CNs：Customer Needs，&lt;ul&gt;
&lt;li&gt;客户需求。&lt;/li&gt;
&lt;li&gt;客户域&lt;/li&gt;
&lt;li&gt;就是客户描述的一大堆自然语言也说不清楚的事情，什么高端大气上档次之类的东西。&lt;/li&gt;
&lt;li&gt;What adds value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FRs：Functional Requirements，&lt;ul&gt;
&lt;li&gt;功能需求。&lt;/li&gt;
&lt;li&gt;功能域&lt;/li&gt;
&lt;li&gt;从CNs域到FRs域的变换，就是把客户漫无边际的需求翻译成一些可定量的参数，比如战舰控制系统的FR有二：1）控制航行方向。2）控制开炮方向。&lt;/li&gt;
&lt;li&gt;What it does&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DPs：Design Parameters，&lt;ul&gt;
&lt;li&gt;设计参数。&lt;/li&gt;
&lt;li&gt;物理域&lt;/li&gt;
&lt;li&gt;实现FRs的物理参数，比如航向控制器和炮塔控制器。&lt;/li&gt;
&lt;li&gt;What it looks like&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PVs：Process Variables，&lt;ul&gt;
&lt;li&gt;过程变量。&lt;/li&gt;
&lt;li&gt;过程域&lt;/li&gt;
&lt;li&gt;没细说，大概是如何实现DPs&lt;/li&gt;
&lt;li&gt;How you make it&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;这四个域里，最重要的是FRs（功能需求）到DPs（设计参数）的映射。 （考虑到我一向憎恶缩写，我会在每一个FRs后面都写上功能需求四个字）。其实我觉得从CNs(客户需求)到FRs(功能需求)的翻译也很重要，但这涉及到人类语言的模糊性，这个步骤还很难科学化。至于DPs(涉及参数）到PVs（过程变量）也就是实现过程，我们写发明通常就是引述为“现有技术”了。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;FRs（功能需求）会有很多啦，可以写成&lt;/p&gt;
$$
FRs=
\begin{bmatrix}FR_1 
\\ FR_2
\\ ...
\\ FR_n
\end{bmatrix}
$$&lt;p&gt;类似的，能够达成FRs（功能需求）的DPs（设计参数）也有很多，可以写成&lt;/p&gt;
$$
DPs=
\begin{bmatrix}DP_1 
\\ DP_2
\\ ...
\\ DP_m
\end{bmatrix}
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;于是，DPs（设计参数）实现FRs（功能需求）这件事情，就可以写成矩阵乘法的形式
$$
FRs=A \times DPs
$$
或者说：
$$
\begin{bmatrix}FR_1 
\\ FR_2
\\ ...
\\ FR_n
\end{bmatrix}=
\begin{bmatrix}A_{11} &amp;amp; A_{12} &amp;amp; ... &amp;amp; A_{1m}
\\ A_{21} &amp;amp;  A_{22} &amp;amp; ... &amp;amp; A_{2m}
\\ ...
\\ A_{n1} &amp;amp;  A_{n2} &amp;amp; ... &amp;amp; A_{nm}
\end{bmatrix}
\begin{bmatrix}DP_1 
\\ DP_2
\\ ...
\\ DP_m
\end{bmatrix}
$$&lt;/p&gt;
&lt;p&gt;当然，不一定是线性的，那工科标准做法就是就求导，反正在小量范围内可以近似成线性的。其实还是类似上面的矩阵，只不过带上了偏导符号而已，还不如原来看得清楚，所以后面就按线性近似来说了。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;然后，华丽丽的矩阵写好以后，其实我们不关心$A_{ij}$的系数具体是怎样的，只关心是否为0，如果不是0，就画个x。
比如USS Monitor号上的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$FR_1$（功能需求1）：调整航向&lt;/li&gt;
&lt;li&gt;$FR_2$（功能需求2）：调整开炮方向&lt;/li&gt;
&lt;li&gt;$DP_1$（设计参数1）：船舵&lt;/li&gt;
&lt;li&gt;$DP_2$（设计参数1）：旋转炮塔&lt;/li&gt;
&lt;/ul&gt;
$$
\begin{bmatrix}FR_1 
\\ FR_2
\end{bmatrix}=
\begin{bmatrix}A_{11} &amp;amp;  A_{12}
\\ A_{21} &amp;amp;  A_{22}
\end{bmatrix}
\begin{bmatrix}DP_1 
\\ DP_2
\end{bmatrix}
$$$$
\begin{bmatrix}FR_1 
\\ FR_2
\end{bmatrix}=
\begin{bmatrix}X &amp;amp;  0
\\ X &amp;amp;  X
\end{bmatrix}
\begin{bmatrix}DP_1 
\\ DP_2
\end{bmatrix}
$$&lt;p&gt;其中转动船舵的时候，船会转向，所以$A_{11}$这里是X，同时船身上的炮塔也跟着船一起转向，所以也影响开炮方向$FR_2$，因此$A_{21}$也是X。
而在旋转炮塔的时候，不影响船的航行方向，所以$A_{12}$这里是0。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="好的设计"&gt;好的设计&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/#%E5%A5%BD%E7%9A%84%E8%AE%BE%E8%AE%A1"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一个好的设计是什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先FRs（功能需求）的数量N，应当等于DPs(设计参数）的数量M。&lt;/li&gt;
&lt;li&gt;每一个FR（功能需求）有且只有一个DP（设计参数）来调整。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就是A矩阵应当是一个对角矩阵，也就是说：&lt;/p&gt;
$$
A=\begin{bmatrix}
X &amp;amp; 0 &amp;amp; ... &amp;amp; 0
\\ 0 &amp;amp;  X &amp;amp; ... &amp;amp; 0
\\ ...
\\ 0 &amp;amp;  0 &amp;amp; ... &amp;amp; X
\end{bmatrix}
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="可行的设计"&gt;可行的设计&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/#%E5%8F%AF%E8%A1%8C%E7%9A%84%E8%AE%BE%E8%AE%A1"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;A矩阵是一个三角形矩阵，如果按照调整顺序来规划DPs(设计参数），那么更确切的说，应当是上三角矩阵&lt;/p&gt;
$$
\mathbf{A}=\left[\begin{array}{ccccc}{X} &amp;amp; {} &amp;amp; {\cdots} &amp;amp; {} &amp;amp; {0} \\ {X} &amp;amp; {X} &amp;amp; {} &amp;amp; {(0)} &amp;amp; {} \\ {X} &amp;amp; {X} &amp;amp; {\ddots} &amp;amp; {} &amp;amp; {\vdots} \\ {\vdots} &amp;amp; {\vdots} &amp;amp; {\ddots} &amp;amp; {\ddots} &amp;amp; {} \\ {X} &amp;amp; {X} &amp;amp; {\dots} &amp;amp; {X} &amp;amp; {X}\end{array}\right]
$$&lt;p&gt;在这种情况下，DPs(设计参数）仍然是可以一定程度decouple的，比如先调整船的航向，然后再调整炮塔的方向，但炮塔方向要先补偿船的转向，再加上需要旋转的角度。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="糟糕的设计"&gt;糟糕的设计&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/#%E7%B3%9F%E7%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;A里面到处都是X，并且无法通过交换FRs（功能需求）和DPs（设计参数）的顺序来形成三角形矩阵。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FRs（功能需求）的数量N，小于 DPs(设计参数）的数量M。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSS Virginia号的情况就是这样，有2个FRs(功能需求）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$FR_1$（功能需求1）：调整航向&lt;/li&gt;
&lt;li&gt;$FR_2$（功能需求2）：调整开炮方向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但只有一个DP(设计参数）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$DP_1$（设计参数1）：船舵&lt;/li&gt;
&lt;/ul&gt;
$$
\begin{bmatrix}FR_1 
\\ FR_2
\end{bmatrix}=
\begin{bmatrix}X 
\\ X 
\end{bmatrix}
\begin{bmatrix}DP_1 
\end{bmatrix}
$$&lt;p&gt;写不成三角矩阵&lt;/p&gt;
&lt;p&gt;于是只好靠装甲厚实扛打&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>公理设计</category><guid>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/</guid><pubDate>Wed, 17 Jul 2019 14:00:00 GMT</pubDate></item><item><title>公理设计笔记（1）</title><link>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_1/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;一个夏日的上午，我在图书馆里闲逛（据@cxqn 说这是有闲阶级才能做的事情），偶遇一本&lt;a href="https://book.douban.com/subject/1238993/"&gt;《公理设计》&lt;/a&gt;，看书名觉得好奇于是拿出来翻了翻，觉得内容不错。网上还可以找到一篇文献&lt;a href="http://blog.sciencenet.cn/home.php?mod=attachment&amp;amp;id=40989"&gt;《公理设计理论及其应用》&lt;/a&gt; 做了一些基本介绍。&lt;/p&gt;
&lt;p&gt;但看起来这是一门课了，所以估计会有公开课来讲解。于是上网搜了一下，还真是找到了&lt;a href="https://www.youtube.com/playlist?list=PLMDNnNJK3B1UlhdIfsFaezkHWbofX7Blj"&gt;MFE 594 An Introduction to Axiomatic Design&lt;/a&gt;，有4节课，大约一共4个多小时，花了两天看完，再回来翻翻书，有一些收获，决定写一点笔记。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;p&gt;首先从1862年11月13日的&lt;a href="https://www.history.com/this-day-in-history/u-s-s-monitor-battles-c-s-s-virginia"&gt;一场海战&lt;/a&gt;讲起。这场海战“标志着蒸汽动力铁甲舰新时代的到来。”&lt;/p&gt;
&lt;p&gt;南方C.S.S的Virginia号战舰，体型庞大，非常凶悍。已经击沉了两艘联邦军舰。北方U.S.S派出了Monitor号，一艘小得多的军舰。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://www.battlefields.org/sites/default/files/styles/gallery_item/public/thumbnails/image/comparison-of-the-css_0.jpg"&gt;
图片来自https://www.battlefields.org/learn/galleries/battle-hampton-roads&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;&lt;/th&gt;
&lt;th align="left"&gt;USS Monitor&lt;/th&gt;
&lt;th align="left"&gt;CSS Virginia&lt;/th&gt;
&lt;th align="left"&gt;V : M&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;长度&lt;/td&gt;
&lt;td align="left"&gt;173.00ft&lt;/td&gt;
&lt;td align="left"&gt;262.75 ft&lt;/td&gt;
&lt;td align="left"&gt;1.52&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;宽度&lt;/td&gt;
&lt;td align="left"&gt;41.33 ft&lt;/td&gt;
&lt;td align="left"&gt;51.16 ft&lt;/td&gt;
&lt;td align="left"&gt;1.24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;排水量&lt;/td&gt;
&lt;td align="left"&gt;987 tons&lt;/td&gt;
&lt;td align="left"&gt;3,200 tons&lt;/td&gt;
&lt;td align="left"&gt;3.25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;船员&lt;/td&gt;
&lt;td align="left"&gt;52&lt;/td&gt;
&lt;td align="left"&gt;350&lt;/td&gt;
&lt;td align="left"&gt;6.73&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;火炮&lt;/td&gt;
&lt;td align="left"&gt;2&lt;/td&gt;
&lt;td align="left"&gt;12&lt;/td&gt;
&lt;td align="left"&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这个比例看起来就是大雄vs胖虎之战。&lt;/p&gt;
&lt;p&gt;CSS Virginia的特点除了大，还有就是都是固定炮塔，两侧和首尾有很多门炮。而USS Monitor有一个可以旋转的炮台。&lt;/p&gt;
&lt;p&gt;一条战舰需要满足两个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调整航行方向&lt;/li&gt;
&lt;li&gt;调整炮击方向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于CSS Virginia，这两个功能需求是“耦合”couple 的，要改变炮击方向，就需要将船只转向。而对于USS Monitor，这两个功能需求则是“解耦合”decouple 的，航行方向与炮击方向无关，炮击方向可以独立调整。&lt;/p&gt;
&lt;p&gt;于是Monitor一直尽量守在Virginia的射击死角攻击，而Virginia则必须不断绕开，于是就不断绕圈。这两条船打了4个小时，Virginia撤退了。&lt;/p&gt;
&lt;p&gt;这是视频公开课上老师讲的一个有趣的例子。老师在课上讲解的时候说Virginia被Monitor给neutralize了，所谓&lt;a href="https://www.vocabulary.com/dictionary/neutralize"&gt;neutralize&lt;/a&gt;，军事上解释为 make incapable of military action，丧失军事能力。但按照history.com的记录，Virginia只是撤退了，毕竟Monitor只有两门炮，而Virginia还有很厚的铁甲。但大雄把胖虎打到先撤退跑了，如果再来一艘结果就不一定了。&lt;/p&gt;
&lt;p&gt;可以引出设计公理的第一条：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;满足功能需求（Functional Requirements, FRs)的参数设计（Design Parameter, DPs) 应当要解耦合（decouple）&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;</description><category>公理设计</category><guid>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_1/</guid><pubDate>Wed, 17 Jul 2019 10:00:00 GMT</pubDate></item></channel></rss>