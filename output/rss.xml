<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GoldenGrape's Blog</title><link>https://goldengrape.github.io/</link><description>This is a blog site for GoldenGrape.</description><atom:link href="https://goldengrape.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>zh_cn</language><copyright>Contents © 2019 &lt;a href="mailto:https://twitter.com/goldengrape"&gt;Golden Grape&lt;/a&gt; </copyright><lastBuildDate>Tue, 03 Sep 2019 04:59:37 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>以电视剧的方式工业化生产MOOC</title><link>https://goldengrape.github.io/posts/bulabula/Industrial_production_of_MOOC_as_TV_series/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;在2013年的时候, 我写过《以电视剧的方式工业化生产MOOC》, 提出&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网络课程可以『电视剧化』的。
完！全！可！以！雇！佣！演！员！ 来！表！演！讲！课！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;昨天发现一个Socratica做的抽象代数课程(&lt;a href="https://www.youtube.com/playlist?list=PLi01XoE8jYoi3SgnnGorR_XOW3IcK-TP6"&gt;Youtube链接&lt;/a&gt;, &lt;a href="https://www.bilibili.com/video/av16765924"&gt;国内Bilibili搬运&lt;/a&gt; ), 课程浅显易懂, 而且老师非常漂亮, 甚至有一点魅惑(参考第5节习题课), 一口气就看了20多节课, 把以前在看&lt;a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+60240013X+sp/about"&gt;《组合数学》&lt;/a&gt;时留下的群论补充了不少. &lt;/p&gt;
&lt;p&gt;&lt;img alt="21-Simple Groups - Abstract Algebra-0001" src="https://i.loli.net/2019/09/01/uxNL68KgnkvZBFO.png"&gt;&lt;/p&gt;
&lt;p&gt;今天经&lt;a href="https://twitter.com/goophile/status/1168011061825425409"&gt;@goophile&lt;/a&gt; 提示, 原来讲课老师是&lt;a href="https://en.wikipedia.org/wiki/Liliana_Castro"&gt;Liliana Castro&lt;/a&gt; 一位巴西女演员, 演过不少电影和电视剧. &lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/9e/Liliana_Castro01.jpg/640px-Liliana_Castro01.jpg"&gt;&lt;/p&gt;
&lt;p&gt;真是表演与公开课结合的典范. 想到其实是一位女演员在讲解李群, 有一种&lt;a href="https://zh.wikipedia.org/zh-hans/%E4%B8%AD%E6%96%87%E6%88%BF%E9%97%B4"&gt;中文屋&lt;/a&gt; 的实验戏剧之感.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;hr&gt;
&lt;p&gt;以下是2013年写的blog&lt;/p&gt;
&lt;p&gt;MOOC有一个好处，就是非实时交流，很多人把这个当成弊端，但其实非实时交流可以使课程制作过程工业化，也就是将老师从一个人拆分成：知识顾问、编剧、导演、演员、配音、配乐、多媒体制作等很多个互相独立的工种。
在此之前课堂上必须由一个人完成，于是会有很多人学问很好但是讲不出来；会讲，但是形象不佳；形象尚可但情绪不到位；情绪有了，却口头语、小动作多；课堂表演不错PPT配色则一塌糊涂；干脆不用PPT了板书的字却拿不出手……所以出一个讲课很好的老师很难。&lt;/p&gt;
&lt;p&gt;网络课程可以『电视剧化』的。&lt;/p&gt;
&lt;p&gt;完！全！可！以！雇！佣！演！员！ 来！表！演！讲！课！&lt;/p&gt;
&lt;p&gt;《生活大爆炸》这个美剧表明，理论物理学博士是可以由一个不懂物理的演员演出来的。
http://tv.sohu.com/s2013/4402/s383695385/
http://tv.sohu.com/s2013/4402/s383695385/&lt;/p&gt;
&lt;p&gt;TBBT表明人们可以相信一个演员演出来的理论物理博士是一个理论物理博士。&lt;/p&gt;
&lt;p&gt;同理，讲课也是。&lt;/p&gt;
&lt;p&gt;去表演系请专业演员，把他/她按照学术明星那样包装，幕后由一批顶尖的专业教授为他来写讲稿、教案，由编剧组织情节，甚至还应该埋下一些悬念。讲课的时候用分镜头，每一句台词在导演的监督下，情绪饱满的演很多遍，不断的喊cut，直到精确的把知识通过情绪传达给观众以后才罢休。&lt;/p&gt;
&lt;p&gt;网络课程制作起来并不困难，要点是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每15分钟一个视频，&lt;/li&gt;
&lt;li&gt;只讲一个知识点，&lt;/li&gt;
&lt;li&gt;不要用PPT!!! 最好是写板书，&lt;/li&gt;
&lt;li&gt;要有真人的活动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;家用摄像机在办公室录制都可以，很多coursera、edx上的课程都是在教授的办公室里录制的，直接在课堂上录制也可以，但要注意声音应该单独用话筒采集。&lt;/p&gt;
&lt;p&gt;由于老师的站位一般活动范围不大，甚至用单反录制效果还会更好。(2019年补充, 使用DJI的OSMO mobile 3, 接手机拍摄, 可以自动跟踪, 效果不错.)&lt;/p&gt;
&lt;p&gt;这是几门老师表演不错的课程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;model thinking：
    *（人物活动与板书/ppt之间的关系）&lt;/li&gt;
&lt;li&gt;生物学导论：
    *（情绪！讲课是要有激情的）&lt;/li&gt;
&lt;li&gt;台湾大学的几门课也还不错
https://www.coursera.org/taiwan&lt;/li&gt;
&lt;li&gt;沃顿的《市场导论》：https://www.coursera.org/course/marketing
已经可以看出是团队制作的样子了：&lt;ul&gt;
&lt;li&gt;讲产品的时候就到商场里面去取外景；&lt;/li&gt;
&lt;li&gt;摄像的用光、虚化之类是专业人士所为；&lt;/li&gt;
&lt;li&gt;老师从头到尾讲话一个错误和停顿都没有，大概是反复录制剪辑过……确实是市场部的人做事的风格。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以电视剧的方式制作出来的课程，也可以按照电视剧的方式来定价、出售和盈利，前后也可以插播广告，捧出来的明星也可以代言产品，没有长出锥子脸的演员也不必自怨自艾。&lt;/p&gt;
&lt;p&gt;康庄大道&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/bulabula/Industrial_production_of_MOOC_as_TV_series/</guid><pubDate>Sun, 01 Sep 2019 04:00:00 GMT</pubDate></item><item><title>角膜屈光手术后IOL计算</title><link>https://goldengrape.github.io/posts/ophthalmology/IOL_calculate_with_post_conrea_refractive_surgery/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;角膜屈光手术, 包括但不限于Lasik, Lasek, PRK, 半飞秒, 全飞秒……, 做完之后多年, 如果出现了白内障, 要换人工晶体. 这时直接代入常规的人工晶体公式是不行的. 要使用新的计算方法.&lt;/p&gt;
&lt;p&gt;好在发明新的人工晶体计算公式是名利双收的好事, 于是过去15年, 至少出现有30种以上的公式. 然后还有更多的临床研究, 对比各种公式的优劣. (医学领域的“什么值得买”)&lt;/p&gt;
&lt;p&gt;最近读了一篇这样的对比综述, &lt;a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6053834/"&gt;Intraocular lens power calculation in eyes with previous corneal refractive surgery&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;python实现&lt;/h3&gt;
&lt;p&gt;于是把其中的各种公式重新用python写了一遍. 代码放在github上: 
&lt;a href="https://github.com/goldengrape/IOL_calculate_with_post_corneal_refractive_surgery"&gt;https://github.com/goldengrape/IOL_calculate_with_post_corneal_refractive_surgery&lt;/a&gt;&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;p&gt;而且, 这次我是练习使用ipywidget做成了交互式的jupyter笔记本. 可以使用滑动条或者填空格来填入参数, 可以实时显示出结果.&lt;/p&gt;
&lt;p&gt;例如:
&lt;!-- TEASER_END --&gt;&lt;img alt="屏幕快照 2019-08-19 11.54.42" src="https://i.loli.net/2019/08/19/hJucql4jdELfyxv.png"&gt;&lt;/p&gt;
&lt;p&gt;但是要实现交互, 在github的ipynb静态渲染不行, 必须要一个能够真正计算的空间才行. 虽然理论上mybinder.org提供了从github直接导入的功能, 但实际上用起来特别慢, 还没搞定. &lt;/p&gt;
&lt;p&gt;因此, 要想测试交互式的功能, 国内只好使用azure notebooks了. 我也放了一份: &lt;a href="https://notebooks.azure.com/goldengrape/projects/iol-calculation-lasik/html/IOL_calc.ipynb"&gt;https://notebooks.azure.com/goldengrape/projects/iol-calculation-lasik/html/IOL_calc.ipynb&lt;/a&gt; 点击硕大的&lt;strong&gt;绿色Clone按钮&lt;/strong&gt;, 给自己Clone一份, 就可以运行交互了. &lt;/p&gt;
&lt;p&gt;&lt;img alt="屏幕快照 2019-08-19 12.48.07" src="https://i.loli.net/2019/08/19/8p3TeWOG5Alfdcs.png"&gt;&lt;/p&gt;
&lt;h3&gt;读后感&lt;/h3&gt;
&lt;p&gt;阅读带有公式的论文, 还是应该自己亲手复现一下.即使是这个领域的经典文章, 里面也有很多错误. 比如: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://sci-hub.tw/10.1016/j.jcrs.2006.08.037"&gt;BESSt公式&lt;/a&gt;的文献里, 这个r没有定义, 猜测应该是rF.
&lt;img alt="BESSt公式" src="https://i.loli.net/2019/08/19/KS6T4azZOhjdLv9.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.ncbi.nlm.nih.gov/pubmed/14670413"&gt;Double K SRK/T公式&lt;/a&gt;的文献里, rpre2和Cw2的2都应该是上标, 是平方.
&lt;img alt="double K" src="https://i.loli.net/2019/08/19/UJnhDqfbxR7eGgF.png"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;到不完全是吹毛求疵, 而是你直接对着文献敲代码运行结果肯定是错的. 也许有一天强AI能够自行阅读医学文献的时候, 一定会惊异人类的容错能力. 这也算是人类的自我保护吧.&lt;/p&gt;
&lt;p&gt;另外, 有些公式的来源真是...我复现Hoffer Q公式的时候, 发现还有tan K这样的过程, 对角膜曲率K求正切? 什么道理, 这量纲不对啊. 是不是印错了? 于是&lt;a href="https://sci-hub.tw/10.1016/S0886-3350(13)80338-0"&gt;仔细读原文&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Haigis" src="https://i.loli.net/2019/08/19/Xch1WpuDea6kJ42.png"&gt;&lt;/p&gt;
&lt;p&gt;原来是Hoffer老先生觉得之前的回归曲线不直, 看起来像tangent曲线, 于是用卡西欧fx-8500G图形计算器开始试, 试啊试, 直到凑出来的公式符合曲线的形态(by trial and error, until a formular produced the desired curve).&lt;/p&gt;
&lt;p&gt;上古文献里的八卦真多.&lt;/p&gt;
&lt;h2&gt;excel实现&lt;/h2&gt;
&lt;!-- 考虑到真正的眼科医生, 是不大可能认真看python程序的, 也不大可能真的去点一下azure notebooks上的clone按钮, 更不可能有一天自己写个处理数据的程序, 用import把我写好的公式导入.  --&gt;

&lt;!-- 
(是的, 我了解你们, 看看“什么值得买”类的评测才是临床看病的正经事, 至于原理不重要, 实现反正机器都有内置的. 我对你们很绝望, 但我仍然爱你们) --&gt;

&lt;p&gt;我还随手写了个&lt;a href="https://github.com/goldengrape/IOL_calculate_with_post_corneal_refractive_surgery/raw/master/IOL_calc.xlsx"&gt;excel文件&lt;/a&gt;.
里面包含了Double K SRK/T、SRK/T、 Hoffer Q、Haigis、Haigis L、Shammas、BESSt公式, 以及一个简单的术后K值转换公式. (原来VB的函数和python差不多, 几乎可以复制粘贴)&lt;/p&gt;
&lt;p&gt;&lt;img alt="excel" src="https://i.loli.net/2019/08/19/H8hRcxvlanGTspz.png"&gt;&lt;/p&gt;
&lt;p&gt;只要像引用普通的excel函数那样使用就可以了. 如果遇到要处理几百个病人数据, 对比上面这些公式的结果, 又懒得一个一个往IOL Master或者PentaCam机器里输入, 那么就可以用这个excel文件了. &lt;/p&gt;
&lt;p&gt;但这些公式只是绑定到这个文件里的, 暂时我还没搞定如何弄成一个可以导入到公式库里面的东西. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上开源小代码, 作为医师节小礼物送给各位同道. 祝医师节快乐.&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;</description><category>ophthalmology</category><guid>https://goldengrape.github.io/posts/ophthalmology/IOL_calculate_with_post_conrea_refractive_surgery/</guid><pubDate>Mon, 19 Aug 2019 04:00:00 GMT</pubDate></item><item><title>如何快速进入工作学习状态</title><link>https://goldengrape.github.io/posts/bulabula/How_to_get_into_work_or_study_quickly/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;h3&gt;工作日前的准备:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;前一天晚上睡前确保在微信“发现页”中已经关闭了朋友圈. &lt;/li&gt;
&lt;li&gt;前一天晚上或之前, 订阅好“无忧公主的数学时间”, 微信号是 wuyoushuxue .&lt;/li&gt;
&lt;li&gt;前一天晚上或之前, 将“无忧公主的数学时间” “添加到桌面”.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;工作日当日早上:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;工作日当天早起, 不要打开微信, 先点击桌面上的“无忧公主的数学时间”快捷方式.&lt;/li&gt;
&lt;li&gt;看一道数学题, 如果一眼就能看出答案, 另外找一道. &lt;/li&gt;
&lt;li&gt;开始日常的洗漱、吃早饭、通勤……, 开始工作.&lt;/li&gt;
&lt;li&gt;注意, 通勤时不要看朋友圈以及其他社交网络, 不要看新闻, 可以通过“讯飞有声”听电子书.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;工作开始后:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;首先进行输出工作, 至少一个番茄时间段(25分钟). 所谓输出就是自己写东西, 比如写代码、写email、写文章、做ppt等.&lt;/li&gt;
&lt;li&gt;休息时可以拿出一张草稿纸, 试着解决无忧公主出的数学题. &lt;/li&gt;
&lt;li&gt;第一个输出时间段之后才可以摸鱼.&lt;/li&gt;
&lt;li&gt;如果刷微信朋友圈, 可以临时开启“发现页”中的朋友圈, 看完后及时关闭.&lt;/li&gt;
&lt;li&gt;刷其他社交网络类似, 尽快及时关闭. &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;以上流程的关键是:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在早起后第一时间, 先往脑子里装一道数学题. 并使之保持悬而未决的状态.&lt;/li&gt;
&lt;li&gt;第一组输出之后才开始允许输入. &lt;/li&gt;
&lt;li&gt;为浏览新闻、社交网络造成一定的困难.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上流程对我自己有一定的作用.&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;h2&gt;可能的原理&lt;/h2&gt;
&lt;p&gt;工作记忆内存一般只有4个扩展槽, 早起装一道数学题, 并且暂时不准使用草稿纸, 导致这道数学题一直占据一个工作内存槽. &lt;/p&gt;
&lt;p&gt;在保持思考数学题的时候, 更容易以客观视角看待问题, 不容易被情绪左右. 而新闻与社交网络中的信息主要以强烈情绪争夺注意力. 因此在第一时间植入数学题后, 能够增强一点免疫. 也就是说, 看到刷屏标题后第一反应不是好奇, 而是“关我屁事”. &lt;/p&gt;
&lt;p&gt;如果要加强效果, 可以将手机放在包里, 不取出, 不放在手边, 反正有信息也会响, 或者手环会提醒.&lt;/p&gt;
&lt;p&gt;如果要更增强效果, 在第一个工作输出时, 使用笔和纸, 不打开电脑.&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/bulabula/How_to_get_into_work_or_study_quickly/</guid><pubDate>Sat, 17 Aug 2019 04:00:00 GMT</pubDate></item><item><title>金葡流简报术</title><link>https://goldengrape.github.io/posts/bulabula/goldengrape_style_ppt/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;h3&gt;简报两大困难&lt;/h3&gt;
&lt;p&gt;根据我多年来做简报，包括但不限于PPT/ Keynote的经验，做简报有两大困难：&lt;strong&gt;一不做二不休&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所谓“一不做”，是不开始做，严重的拖延症发作，几张PPT可能要做上一个星期。只要打开电脑就不可避免会被其他的网站所影响，即使在查阅与简报相关的资料，也可能在维基百科甚至是在pubmed中迷失方向，看了一大堆不相干的文件，学会了许多不相干的知识，但PPT还是没有动。&lt;/p&gt;
&lt;p&gt;另一大困难是“二不休”，可能直到deadline绕颈，被逼不得不动手以后，又在PPT中塞入了太多的内容，写下了太多的文字，加入了太多的动画，在真正演讲的时候排练不足，时间控制不好，讲着讲着发觉时间不够用了，于是不断的“过、过、下一张、下一张”，之前的辛苦制作，给浪费了许多，还给人留下了准备仓促的坏印象。&lt;/p&gt;
&lt;h3&gt;金葡流简报术&lt;/h3&gt;
&lt;p&gt;综上，我根据自己平时的工作特点，开发了一种做简报的新流程，被网友&lt;a href="https://twitter.com/octw"&gt;@octw&lt;/a&gt; 赐名为“金葡流简报术”。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;p&gt;这个简报术很容易，分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用笔和纸先写下演讲时要说的讲稿，&lt;/li&gt;
&lt;li&gt;用语音输入的软件将写好的讲稿输入电脑，分段粘贴进幻灯片的备注中，&lt;/li&gt;
&lt;li&gt;根据每页的讲稿，来选择图片图表，或书写文字，&lt;/li&gt;
&lt;li&gt;其中，如果是书写文字，推荐使用毛笔来写。写完后用Adobe Capture转换成svg，再转换成PPT或者Keynote中的“形状”。&lt;/li&gt;
&lt;li&gt;​然后是利用自己写好的程序，将带有备注的PPT生成由TTS转换语音后的视频，然后自己看看，再作少许修改、排练。也可以简单使用朗读软件，将讲稿文本朗读出来，记录个时间。甚至可以自己去充当朗读软件，只要对着讲稿念出来，进行幻灯片录制即可。​&lt;/li&gt;
&lt;li&gt;录好的语音幻灯可以导出成视频，既可以存档又可以传到网上分享，还可以给听众或学生作为课后复习&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个简报术的特点就是&lt;strong&gt;慢&lt;/strong&gt;，&lt;strong&gt;目的也是慢&lt;/strong&gt;，通过缓慢的过程是进入使自己进入工作流、心流的状态。&lt;/p&gt;
&lt;h3&gt;免拖延&lt;/h3&gt;
&lt;p&gt;在写讲稿的时候最好选择一个安静不受干扰的环境，比如图书馆，给自己留出一定的工作时间，比如上一个25分钟的倒计时，还可以给自己准备一点小小的奖励，比如一块巧克力，但只能在连续工作25分钟以后才可以吃一小块，&lt;/p&gt;
&lt;p&gt;最后也是最重要的准备，将电脑和手机放到够不着的地方，比如图书馆的储物柜里锁上，连续工作25分钟以后才能去查看一下微信和邮件之类。&lt;/p&gt;
&lt;p&gt;这些都是避免被干扰避免触发拖延行为的好方法，更详细的步骤，请参考coursera上面的一门课叫做&lt;a href="https://www.coursera.org/learn/learning-how-to-learn"&gt;learning how to learn&lt;/a&gt;，学习如何学习。其中关于拖延症的治疗讲得很好，我拖延了几个星期以后学完了，受益匪浅。&lt;/p&gt;
&lt;h3&gt;写作文&lt;/h3&gt;
&lt;p&gt;撰写演讲讲稿的过程，其实我们自己已经受了很多年的训练了，就是&lt;strong&gt;写作文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一切均按照写作文的流程来，首先给自己出一个作文题，根据简报内容，根据简报要讲的目的写出一个作文题，然后估计出字数。&lt;/p&gt;
&lt;p&gt;常见的演讲学术会议发言通常是5到10分钟，商业演讲、小讲座可能是15到20分钟，一堂课一般是30到40分钟。通过时间来估计字数，播音员的语速可能会达到每分钟300字以上。但是作为演讲，是要让台下能够听清楚，并理解。因此每分钟最好控制在150到200字。&lt;/p&gt;
&lt;p&gt;那么一个10分钟的小演讲小讲座大约是1500字到2000字，高考作文是要求800字以上，写作时间一般至少留出40分钟，于是你大约需要工作1到2个小时可以写完讲稿。&lt;/p&gt;
&lt;p&gt;写讲稿的时候，如果有什么需要查询的细节内容，可以先画出空格，空着。等完全写完了之后再去打开电脑查找，很多人常年不写字了，可能提笔忘字，正好借此机会多多练习写字，龙飞凤舞即可，是供自己阅读的草稿，不必太工整。&lt;/p&gt;
&lt;p&gt;一旦开始动笔写，恐怕自己会很惊讶于自己的速度。因为通常要准备的简报都是自己熟悉的东西。之前的拖延其实也常常在心中想着草稿，只是没有将其记录下来，所以一旦动笔开始，就写得飞快。&lt;/p&gt;
&lt;p&gt;对了，在行云流水写的时候要有一支好写的笔，就给钢笔灌好墨水或者使用舒服的自动铅笔之类。&lt;/p&gt;
&lt;p&gt;手写讲稿，令我对演讲内容非常熟悉，自己手写的要比输入的印象更深刻，不大可能出现讲着讲着忘词或者卡壳的情况，手写的速度大约是每分钟20字，演讲时说话的速度是每分钟200字，有着10倍的差距，因此我有充足的时间来组织语言。更因为手写慢，所以我这样懒散的人，必定尽量言简意赅。&lt;/p&gt;
&lt;p&gt;用纸和笔还有一大好处是，要增加一倍的显示面积，只需要再添加一张纸就好了。我可以随时调用出之前写的部分或者提纲，也可以随手圈出一段，画个箭头指向另一处。如果临时想到什么，比如所需插图的样子，或者示意图的画法就可以直接在纸上潦草画出讲稿。&lt;/p&gt;
&lt;p&gt;写完之后我的工作就算完成一大半了，有一份手写稿，甚至不必做PPT，我也应该可以在现场写板书的，要知道写板书才是讲课最高境界，PPT什么的都是下等。&lt;/p&gt;
&lt;h3&gt;后处理&lt;/h3&gt;
&lt;p&gt;将手写稿变成电子版，理论上可以用OCR软件，但实际用起来效果并不好，倒是用语音输入软件，念一遍，又快又好。有些过于书面的表达或者容易引起听觉错误的表达方式，在语音输入的时候也比较容易发现。&lt;/p&gt;
&lt;p&gt;录入完成后又是语文课的基本功：分段摘出重点作为每一张幻灯片的展示内容。尽量避免在幻灯片上留下一堆文字，其实留下太多文字是不自信的表现，幻灯片上的大段文字往往是给自己照着念做准备的。现在有了手写稿，应当有充分的信心，所以尽量少写文字。&lt;/p&gt;
&lt;p&gt;能够用图片表达的搜索出图片，需要图表的放入图表，关键数据怕观众听不清才可以打字的方式写出来，最后多多少少还是会有些标题什么的，我建议找比手写更慢的方式：用毛笔来写。&lt;/p&gt;
&lt;p&gt;比起钢笔每分钟20字的速度，我估计毛笔还要再慢一个数量级，每分钟两个字吧，这是最具有个性化的艺术字了，孙过庭说过“书则一字可见其心”。&lt;/p&gt;
&lt;p&gt;​毛笔字可以加工成幻灯片中的“形状”，我&lt;a href="https://goldengrape.github.io/posts/bulabula/import_calligraphy_to_keynote_as_shape"&gt;另外写过教程&lt;/a&gt;，不再详述。转换成形状以后可以有很多华丽的处理。现代的平面展示媒介是投影仪，而不再是宣纸，书法当然也可以与时俱进，&lt;/p&gt;
&lt;p&gt;一切都完成后，可以再把文字转换成语音，这我也做好了&lt;a href="https://goldengrape.github.io/posts/bulabula/fullautomatic_dubbing_slide"&gt;现成的程序&lt;/a&gt;，转好后自己可以听听效果。修改完成后导出成视频可以供大家分享，&lt;/p&gt;
&lt;p&gt;以上就是金葡流简报术的基本方法，驽马十驾功在不舍，输出慢一点完成更快。&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/bulabula/goldengrape_style_ppt/</guid><pubDate>Tue, 13 Aug 2019 10:00:00 GMT</pubDate></item><item><title>成人自学的困难</title><link>https://goldengrape.github.io/posts/bulabula/adult_self_study/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;昨天翻译完了&lt;a href="https://goldengrape.github.io/posts/python/15_pages_python_tutorial_translated/"&gt;15页的python教程&lt;/a&gt;，想就成人自学再说说。&lt;/p&gt;
&lt;h2&gt;现象&lt;/h2&gt;
&lt;p&gt;python上手应该很容易，如果有老师在身边督促指导，就用这15页的教程，恐怕快则一下午，慢则一周就可以自己写一些简单的应用了。&lt;/p&gt;
&lt;p&gt;但学python真的花费了我很长很长时间，我发现我从2003年就开始学习python，一直学到2017年才算学会了基础（因此万幸躲过了python 2）。用时14年，而不是7天。&lt;/p&gt;
&lt;h2&gt;原因&lt;/h2&gt;
&lt;p&gt;究其原因，我觉得是因为&lt;strong&gt;放弃太容易&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;成年人有稳定的收入，有常规的工作、生活。要维持这些，以前学会的东西已经够用了。学习新东西在短期内并不会对生活造成什么太大改善，如果放弃学习，短期内也不会产生什么不良后果。&lt;/p&gt;
&lt;p&gt;相比起来学生时代就非常不同，别说放弃一门课，就是一门课的成绩稍微下降一些，也会寝食难安。如果挂科了，简直是天塌下来一半。想起来我大一的时候每周40节课上满，必修加选修上了13门课。（没错，我翘了一门必修课在同一时间选了另一门选修课）。&lt;/p&gt;
&lt;p&gt;理论上，要把学习压力重新加在自己身上，成人也可以快速学习，大家都是学霸出身，没什么理由学不会。但实际上，虚拟的压力并不是压力，没有实质性的威胁算不上威胁。&lt;/p&gt;
&lt;h2&gt;解决方案：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;尽量平滑学习曲线：放弃的理由常常是一丝一毫的困难，一旦放下就很难再捡起来，或者很久以后才能捡起来。那么，就尽量不要制造额外的一丝一毫的困难吧，比如：&lt;/li&gt;
&lt;li&gt;用1500页的书去学python。天呐，1500页的小说我都要犹豫是不是去看，何况1500的教科书。&lt;a href="https://github.com/goldengrape/PartIA-Computing-Michaelmas-zh-CN"&gt;15页的python教程&lt;/a&gt;已经都觉得长了。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在本地电脑上用pip安装python库。类似可以推广到在本地电脑上安装开发环境学习某种语言。那绝对是可怕的拦路虎。&lt;a href="https://repl.it"&gt;REPL.it&lt;/a&gt;上已经做好了几乎所有语言，打开网页用就行了。或者用各种&lt;a href="https://goldengrape.github.io/posts/python/na-xie-zai-xian-de-jupyter/"&gt;在线的jupyter&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;享受过程(process)，而不是追求结果(product)。这是从coursera课程&lt;a href="https://www.coursera.org/learn/learning-how-to-learn/home/welcome"&gt;“学习如何学习”&lt;/a&gt;上学来的一招。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;这一部分的视频&lt;a href="https://www.youtube.com/watch?v=gCKcqLVGnSg&amp;amp;list=PLievC1UeaSOD3EBaJaHstTKIXS51Sfjwo&amp;amp;index=20&amp;amp;t=0s"&gt;在此&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;就是说把学习作为日常消遣的一个选项，既然都是kill time，那么看电视剧和看公开课也是可能互换的。&lt;a href="https://www.coursera.org/learn/shiji"&gt;《史记》&lt;/a&gt;、&lt;a href="http://www.xuetangx.com/courses/course-v1:TsinghuaX+00612642X+sp/about"&gt;《资治通鉴》&lt;/a&gt;里，随便翻出个故事，不比现在电视剧里的情节狗血多了。&lt;ul&gt;
&lt;li&gt;市场环境不好，公司里能干的员工一个接一个辞职。有一天一个基层程序员刚跑，CFO就去追了，追回来以后还让CEO给提升到CTO的职位。CEO看了看简历，该程序员原来在竞争对手那边一直就是个小PM，没做过什么大项目，还曾经被拖库攻击过。但CFO坚持。现在如果你是CEO，该怎么办？剧情狗血吧，哪有这种公司会发生这种事情呢。这个故事又叫做“萧何月下追韩信”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;既然是享受过程，就不要问自己学了多少，学到什么水平了，练习慢慢做，经常做就可以。三天打鱼两天晒网是最佳，不要给自己太大压力，也不要有太大幻想。“无挂碍故，远离颠倒梦想，究竟涅槃”。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如，这是前一段练字的结果，写到开心就好。
&lt;img alt="未命名" src="https://i.loli.net/2019/08/03/AuevRE7mDhYxKaj.png"&gt;&lt;/p&gt;
&lt;p&gt;补充一下：&lt;/p&gt;
&lt;p&gt;享受学习的过程本身，享受学到的知识和技能，这种“自由而无用”的事情，只有成人才能体会到乐趣。儿童是很难从练琴、练字、练球、练拳……体会到乐趣的。能够把重复行为作为冥想过程来享受的，只能是衣食无忧的成人。&lt;/p&gt;
&lt;h2&gt;误解&lt;/h2&gt;
&lt;p&gt;贴出本文后，&lt;a href="https://twitter.com/eMuyi/status/1157559988799209472"&gt;eMuyi认为&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有明确 motivation 的学习就是很低效。如果有一个明确目标，比如建立个人网站，学编程就很简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有明确需求驱动的学习过程确实是高效的，但是这也是最容易被放弃的。对于成年人的学习，最容易质疑的就是需求本身。比如“建立个人网站”，是自己学成全栈，还是直接找个静态网站生成工具然后写写markdown？甚至找个外包花钱做一个。这样一比较，得出的结论很可能是“我这岁数再学习______实属浪费时间”。&lt;/p&gt;
&lt;p&gt;很可能在一定经济实力之后，各种明确的目标都是可以被购买的。而自身的时间价值如果又很高，两者比较就容易选择外包购买而不是自己学习。这和年轻学生又不一样，当学生的时候外包买不起，只好自己学。&lt;/p&gt;
&lt;p&gt;欲速则不达。&lt;/p&gt;
&lt;p&gt;所以前面我给出的解决方案中，就是要&lt;strong&gt;放弃&lt;/strong&gt;明确的学习目的，转而体会学习过程中的乐趣。这种乐趣才是持久的，可记忆的。&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/bulabula/adult_self_study/</guid><pubDate>Sat, 03 Aug 2019 04:01:00 GMT</pubDate></item><item><title>15页python教程翻译</title><link>https://goldengrape.github.io/posts/python/15_pages_python_tutorial_translated/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;起因是有人把一句戏言当真了。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://twitter.com/wangpei/status/1133030820128550912"&gt;王佩说&lt;/a&gt;开始看：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;中文版的《Python学习手册》，厚厚两大本，1500页。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我一看就觉得他学Python的计划要危险了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;别把这事弄复杂了，python就是轻巧的语言，15页的教程满足日常上手即可，然后每用到一个模块再临时去stackoverflow上查。等各个常用模块都用过一遍了，再去看书什么的。
买回来1500页的厚书，高概率是学不下去了。
动手，并且体验写代码的乐趣，才是学语言最重要的事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两个月以后&lt;a href="https://twitter.com/YvCii/status/1147408620755120128"&gt;波澜&lt;/a&gt;翻出这条推，问&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请教15页的教程有名字吗？谢谢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我其实只是把1500页删掉两个0，随口说出的15页。但我确实觉得网上高概率能有个15页的python教程。于是搜了搜，果然找到一个还不错的。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/CambridgeEngineering/PartIA-Computing-Michaelmas"&gt;PartIA-Computing-Michaelmas&lt;/a&gt; 是剑桥大学Engineering &lt;a href="https://en.wikipedia.org/wiki/Tripos"&gt;Tripos&lt;/a&gt;的课程。关于python的13节，关于IPython magic command的1节，关于Jupyter notebook使用的1节，一共正好15节课。每课一个jupyter页面，一共15“页”。&lt;/p&gt;
&lt;p&gt;我看了看内容，还不错，覆盖的多数科学计算所需要的内容，也就是我说的“满足日常上手”。而且附带有练习题，并且可以直接在&lt;a href="https://notebooks.azure.com/garth-wells/projects/CUED-IA-Computing-Michaelmas"&gt;azure notebooks上运行&lt;/a&gt;。满足我说的：“动手，并且体验写代码的乐趣，才是学语言最重要的事情。”&lt;/p&gt;
&lt;p&gt;里面还有不少我以前不知道的知识与八卦，比如&lt;a href="https://en.wikipedia.org/wiki/Cluster_(spacecraft)#Launch_failure"&gt;阿丽亚娜5号为什么爆炸&lt;/a&gt;，&lt;a href="https://en.wikipedia.org/wiki/MIM-104_Patriot#Failure_at_Dhahran"&gt;爱国者导弹为什么工作100小时以后就放过了飞毛腿&lt;/a&gt;，&lt;a href="https://www.theguardian.com/business/2015/may/01/us-aviation-authority-boeing-787-dreamliner-bug-could-cause-loss-of-control"&gt;波音787为什么每284天就要重启&lt;/a&gt;……很有意思。&lt;/p&gt;
&lt;p&gt;比我自己写的&lt;a href="https://github.com/goldengrape/Python-for-ophthalmologist"&gt;面向眼科医生的python教程&lt;/a&gt;要好。考虑到我一直想着有朝一日可以开个工作坊给一群眼科大夫们培训一下午python，让大家学会写基本的程序，以后也方便交流。所以我就把这15页的教程给翻译成中文了。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/goldengrape/PartIA-Computing-Michaelmas-zh-CN"&gt;15页python教程的中文翻译版&lt;/a&gt; ： https://github.com/goldengrape/PartIA-Computing-Michaelmas-zh-CN&lt;/p&gt;
&lt;p&gt;目前翻译得比较粗略，可能还有很多需要修改的地方，反正是在github上，随手就可以修正。也欢迎各位读者多多提issue，帮忙改进。&lt;/p&gt;
&lt;p&gt;谢谢。学习愉快。&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/python/15_pages_python_tutorial_translated/</guid><pubDate>Sat, 03 Aug 2019 04:00:00 GMT</pubDate></item><item><title>大神面镜维修</title><link>https://goldengrape.github.io/posts/bulabula/how_to_fix_aqua_lung_sphera_mask/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;p&gt;今天潜水的时候，发现面镜漏水。仔细观察，发现是胶垫没有很好包裹面镜镜片的边缘。可能是挤压造成了镜片和胶套的变形，导致有一点点松脱。&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMG_20190721_214540" src="https://i.loli.net/2019/07/21/5d347437d6c0c44307.jpg"&gt;
（事后复原出问题的部分）&lt;/p&gt;
&lt;p&gt;在水边弄了一会儿没有搞定，反而把镜片整个给拆下来了。这面镜可是我自由潜水老师赠我的宝物，回来后经过一番努力终于修好，&lt;/p&gt;
&lt;p&gt;大神面镜，准确的说应该是Aqua Lung Sphera Mask，&lt;/p&gt;
&lt;p&gt;&lt;img alt="IMG_20190721_214303" src="https://i.loli.net/2019/07/21/5d34756a82b2d47149.jpg"&gt;
拆解过程详解如下，不失一般性以右眼为例：&lt;/p&gt;
&lt;!-- TEASER_END --&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将面镜翻90度，底面(鼻孔区域)向上。
&lt;img alt="MVIMG_20190721_212535" src="https://i.loli.net/2019/07/21/5d3476de4dc2618712.jpg"&gt;
&lt;img alt="IMG_20190721_214343" src="https://i.loli.net/2019/07/21/5d3475f43d64398116.jpg"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在灰黑交接处，使用一个小号的一字改锥，从此处插入。插入位置尽量靠近内侧边缘
&lt;img alt="IMG_20190721_214359" src="https://i.loli.net/2019/07/21/5d3476548b38753663.jpg"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改锥下压并且手轻轻向鼻侧移动，撬动灰色塑料套，面镜的下缘会松脱。
&lt;img alt="IMG_20190721_214450" src="https://i.loli.net/2019/07/21/5d3476a1ee4aa44054.jpg"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这张图片可以看出面镜的黑色下缘通过一个卡扣固定在灰色的塑料套内。图中绿色圆圈标出。一字改锥就是把这个卡扣给松脱了，就可以取出面镜下缘。
&lt;img alt="MVIMG_20190721_212627" src="https://i.loli.net/2019/07/21/5d34778b13eee39262.jpg"&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面镜下缘取出后，小心把镜片装入到胶套中，确保胶套包裹住镜片边缘的内外表面。然后再将面镜下缘重新插入回去即可。注意插入的时候，那个三角形结构的底边要紧贴面镜的上缘部分。在将面镜下缘插入时，要小心不要让胶套变形太厉害，免得好不容易插回去时镜片没有放对位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;学会这一招以后，似乎可以用来更换面镜的镜片了。&lt;/p&gt;&lt;/div&gt;</description><guid>https://goldengrape.github.io/posts/bulabula/how_to_fix_aqua_lung_sphera_mask/</guid><pubDate>Sun, 21 Jul 2019 13:00:00 GMT</pubDate></item><item><title>公理设计笔记（4）</title><link>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;所以“公理设计”，就是基于两个公理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大化功能模块的独立性&lt;/li&gt;
&lt;li&gt;最小化信息量（～=最大化成功实施的可能性）&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;这样做的好处：&lt;/p&gt;
&lt;h2 id="甲方总是善变的"&gt;甲方总是善变的&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/#%E7%94%B2%E6%96%B9%E6%80%BB%E6%98%AF%E5%96%84%E5%8F%98%E7%9A%84"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;客户需求就是用来不断改变的，就是用来不断折腾乙方的，因为甲方通常也不知道到底要什么，得折腾几次试试看，才能明确目标。如果把搜索引擎看作是乙方，这跟搜索个信息是一样的，搜索就是个学习的过程，一开始的时候往往我也不知道搜索什么，搜几个词试过以后才能明确到底要找什么。我当过甲方也当过乙方，我知道大家都是地球人，客户需求就是个不断变化的过程。&lt;/p&gt;
&lt;p&gt;但deadline是不变的。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;如果能够一开始把FRs(功能需求)和DPs(设计参数)独立得很好，那么已经做过的事情就不算完全浪费，还有可重用的可能性。独立性越高，浪费的工作就越少。&lt;/p&gt;
&lt;p&gt;而如果各个功能模块一开始就搅合在一起，那需求改了，就只好从头开始了。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2019/07/18/5d3071310697641566.png" alt="MFE 594 An Introduction to Axiomatic Design Part 4-qURM1A1BZJw-0001.png"&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="面向对象与结构化"&gt;面向对象与结构化&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我最早学计算机语言的时候，还是结构化编程的时代，后来才开始面向对象编程。我其实一直尽量躲避面向对象编程。一部分是因为我只是做些科学计算，多数情况下一个东西算一遍就完了，不需要建立同一个类的多个实体；另一部分原因是因为设定类这事太“艺术”了，我不知道应该怎么设定，比如一个光路追踪的程序，是把光线设一个类，还是把界面设一个类，还是光线和界面都设定成类。&lt;/p&gt;
&lt;p&gt;《公理设计》这本书中专门有一章讲面向对象的软件设计，我还要再仔细看看这部分。争取能再深入理解一些。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="创新发明的套路"&gt;创新发明的套路&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/#%E5%88%9B%E6%96%B0%E5%8F%91%E6%98%8E%E7%9A%84%E5%A5%97%E8%B7%AF"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;发明是有套路的，作为发明家我知道一些。这里又提供了一组思路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果现有技术中有耦合的部分，看看能否解耦合？&lt;/li&gt;
&lt;li&gt;现有技术中的FRs(功能需求)是否满足“不重复不漏项”的原则？&lt;/li&gt;
&lt;li&gt;重新在不同的域上划分不同层级的FRs(功能需求)&lt;/li&gt;
&lt;li&gt;新的技术/其他领域的技术是否可以突破现有的约束条件？&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>公理设计</category><guid>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_4/</guid><pubDate>Thu, 18 Jul 2019 12:00:00 GMT</pubDate></item><item><title>公理设计笔记（3）</title><link>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_3/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;前面讲解了目的，要尽量形成FRs（功能需求）与DPs(设计参数）的解耦合对应关系&lt;/p&gt;
&lt;p&gt;尽量对角矩阵形成：
$$
FRs=\begin{bmatrix}
X &amp;amp; 0 &amp;amp; ... &amp;amp; 0
\\ 0 &amp;amp;  X &amp;amp; ... &amp;amp; 0
\\ ...
\\ 0 &amp;amp;  0 &amp;amp; ... &amp;amp; X
\end{bmatrix} DPs
$$&lt;/p&gt;
&lt;p&gt;或者至少形成三角形矩阵：
$$
FRs=\begin{bmatrix}
X &amp;amp; 0 &amp;amp; ... &amp;amp; 0
\\ X &amp;amp;  X &amp;amp; ... &amp;amp; 0
\\ ...
\\ 0 &amp;amp;  X &amp;amp; ... &amp;amp; X
\end{bmatrix} DPs
$$&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;实际过程中是分层级对FRs（功能需求）与DPs(设计参数）进行分解的。先从&lt;/p&gt;
$$
\begin{bmatrix}
FR_1
\\ FR_2
\end{bmatrix}
=
\begin{bmatrix}
X &amp;amp; 0 
\\ X &amp;amp;  X 
\end{bmatrix} 
\begin{bmatrix}
DP_1
\\ DP_2
\end{bmatrix}
$$&lt;p&gt;开始，&lt;/p&gt;
&lt;p&gt;然后再把$FR_1$（功能需求）拆解成$FR_{1.1}, FR_{1.2}$，变成类似这个意思：&lt;/p&gt;
$$
\begin{bmatrix}
\begin{bmatrix}
FR_{1.1}
\\ FR_{1.2}
\end{bmatrix}
\\ FR_2
\end{bmatrix}
=
\begin{bmatrix}
\begin{bmatrix}
X &amp;amp; 0
\\ X &amp;amp; X
\end{bmatrix}&amp;amp; 0 
\\ X &amp;amp;  X 
\end{bmatrix} 
\begin{bmatrix}
\begin{bmatrix}
DP_{1.1}
\\ DP_{1.2}
\end{bmatrix}
\\ DP_2
\end{bmatrix}
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在拆分FRs（功能需求）的时候，要求是&lt;a href="https://zh.wikipedia.org/zh-hans/MECE%E5%8E%9F%E5%88%99"&gt;MECE&lt;/a&gt; min原则，也就是"不重复不漏项"并且总数尽量少。MECE := Mutually Exclusive Collectively Exhaustive，课程中使用的是CEME，可能商科里用MECE更多，反正一个意思。&lt;/p&gt;
&lt;p&gt;比如3D打印机的FR(功能需求)之一是要求在$FR_1$打印头空间内移动，那么就可以拆分成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$FR_{1.1}$ 在X轴方向移动&lt;/li&gt;
&lt;li&gt;$FR_{1.2}$ 在Y轴方向移动&lt;/li&gt;
&lt;li&gt;$FR_{1.3}$ 在Z轴方向移动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样的拆分方式显然是MECE的，当然也可以拆分成圆柱坐标系、球坐标系等等。不同的分解方式对应着不同的解决方案。&lt;/p&gt;
&lt;p&gt;对于DPs(设计参数)的拆分，目的是尽量形成对角矩阵，或者至少是三角形矩阵，那么就应当尽量让右上角的区域保持为0。而且在拆分DPs(设计参数)的时候，约束条件是继承的，比如$DP_1$是在中国建厂，那么$DP_{1.1},DP_{1.2}$就不能把工厂建立到越南去。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在实际操作中，拆分是一点一点来进行的。说叫ZigZag。&lt;/p&gt;
&lt;p&gt;先把$FR_1$（功能需求）拆解成$FR_{1.1}, FR_{1.2}$，拆分好$FR_1$（功能需求）以后，再去拆分$DP_1$(设计参数)，拆好了DPs(设计参数)以后，再返回来拆下一个$FR$（功能需求）&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.loli.net/2019/07/18/5d3030b9d457e37686.png" alt="屏幕快照 2019-07-18 16.40.58.png"&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;拆分过程可以用个电子表格来做，最好再弄成可折叠的，似乎有专用的软件可以画图，但不知道excel或者其他通用的简单工具有没有这样的功能。注意子节点上的相关性X，一定要表现在父节点上。比如检查时发现调整$DP_{2}$时$FR_{12}$也跟着变，那$DP_{2}$其实与$FR_1$就是耦合的，中间肯定在某个步骤出错了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th style="text-align:left"&gt;FRs&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_1$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{11}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{12}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{121}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{122}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{123}$&lt;/th&gt;
&lt;th style="text-align:left"&gt;$DP_{2}$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_1$&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{11}$&lt;/td&gt;
&lt;td style="text-align:left"&gt;$\space$&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{12}$&lt;/td&gt;
&lt;td style="text-align:left"&gt;$\space$&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;0&lt;/td&gt;
&lt;td style="text-align:left"&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{121}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{122}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{123}$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;$FR_{2}$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;当有几个不同的拆分FRs(功能需求)的方法，得到了不同的DPs(设计参数)以后。如何判定那种方式更好呢？毫无疑问会陷入到办公室争吵中。&lt;/p&gt;
&lt;p&gt;公理设计的第二条公理：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;要令信息量最小&lt;/p&gt;
&lt;/blockquote&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;这里的信息量，是原教旨的信息量。记住这是MIT教授的书，WPI教授的课。&lt;/p&gt;
$$
I=-\sum_{i}^{\sigma(\mathrm{FR})} \log _{2} P_{i}
$$&lt;p&gt;其中$P_i$是$FR_i$实现的概率&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;在我理解，这只是实现概率最大化的恐怖公式表达而已。这一部分我还没有深究，毕竟我能想到一组DPs(设计参数)就已经不错了。&lt;/p&gt;
&lt;p&gt;这个公理大约对硬件选型的时候更有意义，比如同一个目的，在资金约束条件下，要选精度高一点，冗余大一点的零件。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>公理设计</category><guid>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_3/</guid><pubDate>Thu, 18 Jul 2019 02:00:00 GMT</pubDate></item><item><title>公理设计笔记（2）</title><link>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/</link><dc:creator>Golden Grape</dc:creator><description>&lt;div&gt;&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;如同商学院说事一定要画四格表，工学院说事一定要写向量和矩阵的。这种表述就是工科癖好。&lt;/p&gt;
&lt;!-- TEASER_END --&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;有四个域（Domain）：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;ul&gt;
&lt;li&gt;CNs：Customer Needs，&lt;ul&gt;
&lt;li&gt;客户需求。&lt;/li&gt;
&lt;li&gt;客户域&lt;/li&gt;
&lt;li&gt;就是客户描述的一大堆自然语言也说不清楚的事情，什么高端大气上档次之类的东西。&lt;/li&gt;
&lt;li&gt;What adds value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FRs：Functional Requirements，&lt;ul&gt;
&lt;li&gt;功能需求。&lt;/li&gt;
&lt;li&gt;功能域&lt;/li&gt;
&lt;li&gt;从CNs域到FRs域的变换，就是把客户漫无边际的需求翻译成一些可定量的参数，比如战舰控制系统的FR有二：1）控制航行方向。2）控制开炮方向。&lt;/li&gt;
&lt;li&gt;What it does&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DPs：Design Parameters，&lt;ul&gt;
&lt;li&gt;设计参数。&lt;/li&gt;
&lt;li&gt;物理域&lt;/li&gt;
&lt;li&gt;实现FRs的物理参数，比如航向控制器和炮塔控制器。&lt;/li&gt;
&lt;li&gt;What it looks like&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PVs：Process Variables，&lt;ul&gt;
&lt;li&gt;过程变量。&lt;/li&gt;
&lt;li&gt;过程域&lt;/li&gt;
&lt;li&gt;没细说，大概是如何实现DPs&lt;/li&gt;
&lt;li&gt;How you make it&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;这四个域里，最重要的是FRs（功能需求）到DPs（设计参数）的映射。 （考虑到我一向憎恶缩写，我会在每一个FRs后面都写上功能需求四个字）。其实我觉得从CNs(客户需求)到FRs(功能需求)的翻译也很重要，但这涉及到人类语言的模糊性，这个步骤还很难科学化。至于DPs(涉及参数）到PVs（过程变量）也就是实现过程，我们写发明通常就是引述为“现有技术”了。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;FRs（功能需求）会有很多啦，可以写成&lt;/p&gt;
$$
FRs=
\begin{bmatrix}FR_1 
\\ FR_2
\\ ...
\\ FR_n
\end{bmatrix}
$$&lt;p&gt;类似的，能够达成FRs（功能需求）的DPs（设计参数）也有很多，可以写成&lt;/p&gt;
$$
DPs=
\begin{bmatrix}DP_1 
\\ DP_2
\\ ...
\\ DP_m
\end{bmatrix}
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;于是，DPs（设计参数）实现FRs（功能需求）这件事情，就可以写成矩阵乘法的形式
$$
FRs=A \times DPs
$$
或者说：
$$
\begin{bmatrix}FR_1 
\\ FR_2
\\ ...
\\ FR_n
\end{bmatrix}=
\begin{bmatrix}A_{11} &amp;amp; A_{12} &amp;amp; ... &amp;amp; A_{1m}
\\ A_{21} &amp;amp;  A_{22} &amp;amp; ... &amp;amp; A_{2m}
\\ ...
\\ A_{n1} &amp;amp;  A_{n2} &amp;amp; ... &amp;amp; A_{nm}
\end{bmatrix}
\begin{bmatrix}DP_1 
\\ DP_2
\\ ...
\\ DP_m
\end{bmatrix}
$$&lt;/p&gt;
&lt;p&gt;当然，不一定是线性的，那工科标准做法就是就求导，反正在小量范围内可以近似成线性的。其实还是类似上面的矩阵，只不过带上了偏导符号而已，还不如原来看得清楚，所以后面就按线性近似来说了。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;p&gt;然后，华丽丽的矩阵写好以后，其实我们不关心$A_{ij}$的系数具体是怎样的，只关心是否为0，如果不是0，就画个x。
比如USS Monitor号上的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$FR_1$（功能需求1）：调整航向&lt;/li&gt;
&lt;li&gt;$FR_2$（功能需求2）：调整开炮方向&lt;/li&gt;
&lt;li&gt;$DP_1$（设计参数1）：船舵&lt;/li&gt;
&lt;li&gt;$DP_2$（设计参数1）：旋转炮塔&lt;/li&gt;
&lt;/ul&gt;
$$
\begin{bmatrix}FR_1 
\\ FR_2
\end{bmatrix}=
\begin{bmatrix}A_{11} &amp;amp;  A_{12}
\\ A_{21} &amp;amp;  A_{22}
\end{bmatrix}
\begin{bmatrix}DP_1 
\\ DP_2
\end{bmatrix}
$$$$
\begin{bmatrix}FR_1 
\\ FR_2
\end{bmatrix}=
\begin{bmatrix}X &amp;amp;  0
\\ X &amp;amp;  X
\end{bmatrix}
\begin{bmatrix}DP_1 
\\ DP_2
\end{bmatrix}
$$&lt;p&gt;其中转动船舵的时候，船会转向，所以$A_{11}$这里是X，同时船身上的炮塔也跟着船一起转向，所以也影响开炮方向$FR_2$，因此$A_{21}$也是X。
而在旋转炮塔的时候，不影响船的航行方向，所以$A_{12}$这里是0。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="好的设计"&gt;好的设计&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/#%E5%A5%BD%E7%9A%84%E8%AE%BE%E8%AE%A1"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一个好的设计是什么呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先FRs（功能需求）的数量N，应当等于DPs(设计参数）的数量M。&lt;/li&gt;
&lt;li&gt;每一个FR（功能需求）有且只有一个DP（设计参数）来调整。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就是A矩阵应当是一个对角矩阵，也就是说：&lt;/p&gt;
$$
A=\begin{bmatrix}
X &amp;amp; 0 &amp;amp; ... &amp;amp; 0
\\ 0 &amp;amp;  X &amp;amp; ... &amp;amp; 0
\\ ...
\\ 0 &amp;amp;  0 &amp;amp; ... &amp;amp; X
\end{bmatrix}
$$
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="可行的设计"&gt;可行的设计&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/#%E5%8F%AF%E8%A1%8C%E7%9A%84%E8%AE%BE%E8%AE%A1"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;A矩阵是一个三角形矩阵，如果按照调整顺序来规划DPs(设计参数），那么更确切的说，应当是上三角矩阵&lt;/p&gt;
$$
\mathbf{A}=\left[\begin{array}{ccccc}{X} &amp;amp; {} &amp;amp; {\cdots} &amp;amp; {} &amp;amp; {0} \\ {X} &amp;amp; {X} &amp;amp; {} &amp;amp; {(0)} &amp;amp; {} \\ {X} &amp;amp; {X} &amp;amp; {\ddots} &amp;amp; {} &amp;amp; {\vdots} \\ {\vdots} &amp;amp; {\vdots} &amp;amp; {\ddots} &amp;amp; {\ddots} &amp;amp; {} \\ {X} &amp;amp; {X} &amp;amp; {\dots} &amp;amp; {X} &amp;amp; {X}\end{array}\right]
$$&lt;p&gt;在这种情况下，DPs(设计参数）仍然是可以一定程度decouple的，比如先调整船的航向，然后再调整炮塔的方向，但炮塔方向要先补偿船的转向，再加上需要旋转的角度。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="cell border-box-sizing text_cell rendered"&gt;&lt;div class="prompt input_prompt"&gt;
&lt;/div&gt;&lt;div class="inner_cell"&gt;
&lt;div class="text_cell_render border-box-sizing rendered_html"&gt;
&lt;h2 id="糟糕的设计"&gt;糟糕的设计&lt;a class="anchor-link" href="https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/#%E7%B3%9F%E7%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1"&gt;¶&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;A里面到处都是X，并且无法通过交换FRs（功能需求）和DPs（设计参数）的顺序来形成三角形矩阵。比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FRs（功能需求）的数量N，小于 DPs(设计参数）的数量M。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CSS Virginia号的情况就是这样，有2个FRs(功能需求）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$FR_1$（功能需求1）：调整航向&lt;/li&gt;
&lt;li&gt;$FR_2$（功能需求2）：调整开炮方向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但只有一个DP(设计参数）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$DP_1$（设计参数1）：船舵&lt;/li&gt;
&lt;/ul&gt;
$$
\begin{bmatrix}FR_1 
\\ FR_2
\end{bmatrix}=
\begin{bmatrix}X 
\\ X 
\end{bmatrix}
\begin{bmatrix}DP_1 
\end{bmatrix}
$$&lt;p&gt;写不成三角矩阵&lt;/p&gt;
&lt;p&gt;于是只好靠装甲厚实扛打&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>公理设计</category><guid>https://goldengrape.github.io/posts/bulabula/axiomatic_design_note_2/</guid><pubDate>Wed, 17 Jul 2019 14:00:00 GMT</pubDate></item></channel></rss>