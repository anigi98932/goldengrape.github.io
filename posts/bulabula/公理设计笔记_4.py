#!/usr/bin/env python
# coding: utf-8

# 所以“公理设计”，就是基于两个公理：
# 
# * 最大化功能模块的独立性
# * 最小化信息量（～=最大化成功实施的可能性）

# 这样做的好处：
# 
# # 甲方总是善变的
# 
# 客户需求就是用来不断改变的，就是用来不断折腾乙方的，因为甲方通常也不知道到底要什么，得折腾几次试试看，才能明确目标。如果把搜索引擎看作是乙方，这跟搜索个信息是一样的，搜索就是个学习的过程，一开始的时候往往我也不知道搜索什么，搜几个词试过以后才能明确到底要找什么。我当过甲方也当过乙方，我知道大家都是地球人，客户需求就是个不断变化的过程。
# 
# 但deadline是不变的。
# 
# 

# 如果能够一开始把FRs(功能需求)和DPs(设计参数)独立得很好，那么已经做过的事情就不算完全浪费，还有可重用的可能性。独立性越高，浪费的工作就越少。
# 
# 而如果各个功能模块一开始就搅合在一起，那需求改了，就只好从头开始了。
# 
# ![MFE 594 An Introduction to Axiomatic Design Part 4-qURM1A1BZJw-0001.png](https://i.loli.net/2019/07/18/5d3071310697641566.png)
# 

# # 面向对象与结构化
# 
# 我最早学计算机语言的时候，还是结构化编程的时代，后来才开始面向对象编程。我其实一直尽量躲避面向对象编程。一部分是因为我只是做些科学计算，多数情况下一个东西算一遍就完了，不需要建立同一个类的多个实体；另一部分原因是因为设定类这事太“艺术”了，我不知道应该怎么设定，比如一个光路追踪的程序，是把光线设一个类，还是把界面设一个类，还是光线和界面都设定成类。
# 
# 《公理设计》这本书中专门有一章讲面向对象的软件设计，我还要再仔细看看这部分。争取能再深入理解一些。

# # 创新发明的套路
# 
# 发明是有套路的，作为发明家我知道一些。这里又提供了一组思路。
# 
# * 如果现有技术中有耦合的部分，看看能否解耦合？
# * 现有技术中的FRs(功能需求)是否满足“不重复不漏项”的原则？
# * 重新在不同的域上划分不同层级的FRs(功能需求)
# * 新的技术/其他领域的技术是否可以突破现有的约束条件？
